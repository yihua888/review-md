## 第一章、编译阶段

### 1.1 编译原理及编译过程

#### 1.1.1 编译原理

JavaScript 是一门编译语言。与传统的编译语言不同的是，JavaScript 不是提前编译的，编译结果也不能在分布式系统中进行移植。

在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为 **编译**。

1. 分词 / 词法分析
2. 解析 / 语法分析
3. 代码生成

##### 1.1.1.1 分词和词法分析

这个过程会将由字符组成的字符串分解成有意义的代码块（对编程语言来说），这些代码块被称为 词法单元（Token）。

----

```js
const a = 2;
```

这段程序通常会被分解成为下列词法单元：`var`、`a`、`=`、`2`、`;`。

空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。

分词（Tokenizing）和词法分析（Lexing）之间的主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 `a` 是一个独立的词法单元还是其他词法单元的一部分时，调用的是 **有状态的解析规则**，那么这个过程就被称为 **词法分析**。

----

##### 1.1.1.2 解析和语法分析

语法分析（Parsing） 这个过程是将词法单元流转换成一个 由元素逐级嵌套所组成 的代表了程序语法结构的树。这个树被称为 抽象语法树。

##### 1.1.1.3 代码生成

 AST 转换为可执行代码的过程被称为 **代码生成**。这个过程与语言、目标平台等息息相关。 抛开具体细节，简单来说就是有某种方法可以将 `var a = 2;` 的 AST 转化为一组 **机器指令**：创建一个叫做 `a` 的变量（包括 **分配内存** 等），并将一个值存储在变量 `a` 中。

通过上述三个阶段，浏览器已经可以运行我们得到的 **可执行代码**，这三个阶段还有一个合称叫 **编译阶段**。我们把之后对可执行代码的执行称为 **运行阶段**。

#### 1.1.2 编译过程

编译过程中的关键角色：

- **引擎**：从头到尾负责整个 JavaScript 程序的编译及执行过程
- **编译器**：负责语法分析及代码生成等步骤
- **作用域**：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

---

```js
const a = 2;
```

1. 执行流遇到 `var a`，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为`a`。
2. 接下来编译器会为引擎生成运行所需的代码，这些代码被用来处理 `a = 2` 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中，是否存在一个叫作 `a` 的变量，如果是，引擎就会使用这个变量；如果否，引擎就会继续查找该变量。

总结起来就是：

- 编译器在作用域声明变量（如果没有）
- 引擎在运行这些代码时查找该变量，如果作用域中有该变量则进行赋值

在上面的第二步中，引擎执行运行时所需的代码时，会通过查找变量 `a` 来判断它是否已经声明过。查找的过程由作用域进行协助，但是引擎执行怎么查找，会影响最终的查找结果。

还是 `var a = 2;` 这个例子，引擎会为变量 `a` 进行 LHS 查询。当然还有一种 RHS 查询。

> 那么 LHS 和 RHS 查询是什么呢？

这里的 L 代表左侧，R 代表右侧。通俗且不严谨的解释 LHS 和 RHS 的含义就是：**当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。**

那么描述的更准确的一点，RHS 查询与简单的查找某个变量的值毫无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。

从这个角度说，RHS 并不是真正意义上的"赋值操作的右侧"，更准确的说是"非左侧"。所以，我们可以将 RHS 理解成 Retrieve his source value（取到它的源值），这意味着，"得到某某的值"。

那我们来看一段代码深入理解一下 LHS 与 RHS。

```js
function foo(a) {  
    console.log(a);
}
foo(2);
```

- 在 `console.log(a)` 中，变量 `a` 的引用是一个 RHS 引用，因为我们是取到 `a` 的值。并将这个值传递给 `console.log(…)` 方法
- 相比之下，例如： `a = 2` ，调用 `foo(2)` 时，隐式的进行了赋值操作。这里对 `a` 的引用就是 LHS 引用，因为我们实际上不关心当前的值时什么，只要想把 `=2` 这个赋值操作找到一个目标。

LHS 和 RHS 的含义是 **赋值操作的左侧或右侧** 并不一定意味着就是 `= 赋值操作符的左侧或右侧`。

赋值操作还有其他几种形式，因此在概念上最好将其理解 **赋值操作的目标是谁**（LHS） 以及 **谁是赋值操作的源头**（RHS）。

当然上面的程序并不只有一个 LHS 和 RHS 引用：

```js
function foo(a) {
  // 这里隐式的进行了对形参 a 的 LHS 引用。

  // 这里对 log() 方法进行了 RHS 引用，询问 console 对象上是否有 log() 方法。
  // 对 log(a) 方法内的 a 进行 RHS 引用，取到 a 的值。
  console.log(a);
  // 2
}

// 此处调用 foo() 方法，需要调用对 foo 的 RHS 引用。意味着"去找foo这个值，并把它给我"
foo(2);
```

需要注意的是：我们经常会将函数声明 `function foo(a) {...}` 转化为普通的变量赋值（函数表达式） `var foo = function(a) {…}`，这样去理解的话，这个函数是 LHS 查询。但是有一个细微的差别，编译器可以在代码生成的同时处理声明和值的定义，比如引擎执行代码时，并不会有线程专门用来将一个函数值"分配给" `foo`，因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。

### 1.2  词法作用域

作用域就是变量（标识符）适用范围，控制着变量的可见性。

作用域共有两种主要的工作模式：

- 词法作用域/静态作用域
- 动态作用域

JavaScript 采用 **词法作用域**（Lexical Scope），也称为 **静态作用域**。

因为 JavaScript 采用的是词法作用域，因此函数的作用域在函数定义的时候就决定了。

而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

#### 1.2.1 词法作用域/静态作用域

简单来说，词法作用域就是定义在词法阶段的作用域。换句话来说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变

```js
function foo(a) {
  var b = a * 2;

  function brc(c) {
    console.log(a, b, c);
  }

  bar(b * 3);
}

foo(2); // 2, 4, 12
```

![](./img/1-2-1-词法作用域.png)

- 包含着整个全局作用域，其中只有一个标识符：`foo`
- 包含着 `foo` 所创建的作用域，其中有三个标识符：`a`、`bar` 和 `b`
- 包含着 `bar` 所创建的作用域，其中只有一个标识符：`c`

##### 1.2.1.1 查找

作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎利用这些信息来查找标识符的位置。

在上个代码片段中，引擎执行 `console.log` 声明，并依次查找 `a`、`b` 和 `c` 三个变量的引用。

- 它首先从最内部的作用域，也就是 `bar` 函数的作用域气泡开始查找
- 引擎无法在这里找到 `a`，因此会去上一级到所嵌套的 `foo` 的作用域中继续查找。在这里找到了 `a`，因此引擎使用了这个引用
- 对 `b` 来讲也是一样的
- 而对 `c` 来说，引擎在 `bar` 中就找到了它

如果 `a`、`c` 都存在于 `bar` 和 `foo` 的内部，`console.log` 就可以直接使用 `bar` 中的变量，而无需到外面的 `foo` 中查找。

##### 1.2.1.2 遮蔽

**作用域查找会在找到第一个匹配的标识符时停止**。

在多层嵌套作用域中允许定义同名标识符，称为 **遮蔽效应**（内部的标识符遮蔽了外部的标识符）。

抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上层作用域进行查询，直到遇见第一个匹配的标识符为止。

全局变量会自动成为全局对象的属性（比如浏览器中的 Window 对象），因此可以不直接使用全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。

#### 1.2.2 动态作用域

词法作用域最重要的特征是它的定义过程发生在代码的书写阶段。

实际上动态作用域是 JavaScript 另一个重要机制 [this](https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/execution/this) 的表亲。作用域混乱多数是因为词法作用域和 `this` 机制相混淆。

**动态作用域** 并不关心函数和作用域是如何声明以及在何处声明，它只关心它们从何处调用。

换句话说，[作用域链](https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/execution/scope-chain) 是基于 **调用栈** 的，而不是代码中的作用域嵌套。

```js
const a = 2;

function foo() {
  console.log(a);
}

function bar() {
  const a = 3;
  foo();
}

bar();
```

- 如果处于词法作用域，变量 `a` 首先在 `foo` 函数中查找，没有找到。于是 **顺着作用域链到全局作用域** 中查找，找到并赋值为 `2`。所以控制台输出 `2`
- 如果处于动态作用域，同样地，变量 `a` 首先在 `foo` 中查找，没有找到。这里会 **顺着调用栈** 在调用 `foo` 函数的地方，也就是 `bar` 函数中查找，找到并赋值为 `3`。所以控制台输出 `3`

对于两种作用域的区别，简而言之，词法作用域是在 **定义** 时确定的，而动态作用域是在 **运行** 时确定的。

### 1.3 函数作用域

**函数作用域** 指属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的动态特性。

#### 1.3.1 隐藏内部实现

对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码隐藏起来。

实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来隐藏它们。

有很多原因促成了这种基于作用域的隐藏方法。它们大都是从 [最小权限原则](https://zh.wikipedia.org/wiki/最小权限原则) 中引申出来的。

这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都 **隐藏** 起来，比如某个模块或对象的 API 设计。这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中。当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小权限原则，因为可能会暴露过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是 **可以阻止对这些变量或函数进行访问**。

```js
function doSomething(a) {
  b = a + doSomethingElse(a * 2);

  console.log(b * 3);
}

function doSomethingElse(a) {
  return a - 1;
}

var b;

doSomething(2);
// 15
```

在这个代码片段中，变量 `b` 和函数 `doSomethingElse` 应该是 `doSomething` 内部具体实现的私有内容。给予外部作用域对 `b` 和 `doSomethingElse` 的访问权限不仅没有必要，而且可能是危险的，因为它们可能被有意或无意地以非预期的方式使用，从而导致超出了 `doSomething` 的适用条件。更使用的设计会将这些私有的具体内容隐藏在 `doSomething` 内部。

```js
function doSomething(a) {
  function doSomethingElse(a) {
    return a - 1;
  }

  var b;

  b = a + doSomethingElse(a * 2);

  console.log(b * 3);
}

doSomething(2); // 15
```

现在，`b` 和 `doSomethingElse` 都无法从外部被访问，而只能被 `doSomething` 所控制。功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依次进行实现。

#### 1.3.2 规避命名冲突

隐藏作用域中的变量和函数可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。

```js
function foo() {
  function bar(a) {
    // 修改 for 循环所属作用域中的 i
    i = 3;
    console.log(a + i);
  }

  for (var i = 0; i < 10; i++) {
    // 糟糕，无限循环了！
    bar(i * 2);
  }
}

foo();
```

#### 1.3.2.1 全局命名空间

变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。

这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。

```js
const MyReallyCoolLibrary = {
  awesome: 'stuff',
  doSomething: function () {
    // ...
  },
  doAnotherThing: function () {
    // ...
  },
};
```

##### 1.3.2.2 模块管理

另外一种避免冲突的办法和现代的模块机制很接近，就是众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。

显而易见，这些工具并没有能够违反词法作用域规则的功能。它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突，

因此，只要你愿意，即使不使用任何依赖管理工具也可以实现规避冲突的功效。

在任意代码片段外部添加包装函数，可以将内部的变量和函数定义 **隐藏** 起来，外部作用域无法访问包装函数内部的任何内容。

```js
const a = 2;

function foo() {
  // <-- 添加这一行
  const a = 3;
  console.log(a); // 3
} // <-- 以及这一行
foo(); // <-- 以及这一行

console.log(a); // 2
```

虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。首先，必须声明一个具名函数 `foo()` ，意味着 `foo` 这个名称本身"污染"了所在作用域（在这个例子中是全局作用域）。其次，必须显式地通过函数名`foo()`调用这个函数才能运行其中的代码。

如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。

#### 1.3.3 匿名和具名函数表达式

无论是匿名还是具名，都是针对 **函数表达式** 的。函数声明必须有名称，否则报错。

```js
// 函数声明
function foo() {
  // do something
}
```

而函数表达式可以有名称也可以没有名称。

**匿名函数表达式：**

```js
let foo = function () {
  // do something
};
console.log(foo.name);
// foo
```

**具名函数表达式：**

```js
// 不要这样写
let bar = function foobar() {
  // do something
};
console.log(bar.name);
// foobar
```

对于函数表达式最熟悉的场景可能就是回调参数了。

```js
setTimeout(function () {
  console.log('I waited 1 second!');
}, 1000);
```

这叫 **匿名函数表达式**，因为 `function(){}` 是没有名称的标识符。

**注意**：函数表达式可以是匿名的，而 **函数声明** 是不可以省略函数名。

匿名函数表达式的缺点：

- 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难
- 如果没有函数名，当函数需要引用自身时只能使用已经过期的 `arguments.callee` 引用。比如在递归中，另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身
- 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明

行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名时一个最佳实践。

#### 1.3.4 立即执行函数表达式 IIFE

**立即执行函数表达式** 又称 **自执行函数**，社区给他规定了术语为 **IIFE**（Immediately Invoked Function Expression）。

**代码示例**：

```js
(function () {
  // do something
  console.log('IIFE');
})();
```

IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。

```js
var a = 2;
(function IIFE(global) {  var a = 3;  console.log(a);  // 3  console.log(global.a);  // 2})(window);
console.log(a);// 2
```

### 1.4 块作用域

尽管函数作用域是最常见的作用域单元，也是现行大多数 JavaScript 最普遍的设计方法，但其他类型的作用域单元也是存在的，并且通过使用其他类型的作用域单元甚至可以实现维护起来更加优秀、简洁的代码，比如块作用域。

#### 1.4.1 var

ES5 及之前是没有块级变量这个说法的，常规性是用 **闭包** 来防止内存泄漏。

如下所示为 ES5 中 `var` 声明的一些特点：

- 函数内的变量若是带 `var` 声明，则会覆盖外部的全局变量 **优先使用**
- 若是函数内部声明变量不带 `var` 声明，则直接 **覆盖同名的全局变量**
- 函数内存在 [声明提升](https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/compilation/hoisting) 的情况，可以先使用后声明
- `for` 循环中的 `var` 会污染全局（不局限于循环内）

#### 1.4.2 let

`let` 声明使用方法基本和 `var` 相同，而且声明的变量只在其块和子块中可用。 二者之间最主要的区别在于 `var` 声明的变量的作用域是整个封闭函数。

- 不允许重新声明同名变量，会抛出异常，具有唯一性
- 不允许没声明就使用，会抛出异常，只有执行该声明的时候才能使用
- 有自己特色的闭包特性，比如在 `for` 循环的应用中

#### 1.4.3 const

`const` 的用法跟 `let` 差不多，但是 `const` 一定要赋值，不赋值会报错。

`const` 是块级作用域，`const` 跟 `let` 的语义相似，就是用来声明常量的，一旦声明了就不能更改。

值得注意的是 `const` 声明的变量记录的是 **指针**，不可更改的是 **指针**，如果 `const` 所声明的是对象，对象的内容还是可以修改的。

- 与 `let` 一样，具有唯一性，**不可重复声明**
- 可以将 `const` 声明的基本类型变量理解为只读变量，但是其声明的引用类型变量则是可修改的

#### 1.4.4 暂时性死区

使用 `let` 或 `const` 声明的变量，在声明赋值没有到达之前，访问该变量都会导致报错，就连一直以为安全的 `typeof` 也不再安全。

```js
// TDZ1
function foo() {
  // TDZ 开始
  console.log(typeof number);
  let number = 5; // TDZ 结束
}

foo();
// ReferenceError: number is not defined
```

报的错是 `ReferenceError`，如果使用 `var` 声明的话，`number` 输出应该是 `undefined`，从 `let` 声明的变量的块的第一行，到声明变量之间的这个区域被称作 **暂时性死区**（TDZ）。凡是在这个区域使用这些变量都会报错。

```js
// TDZ2
function bar() {
  console.log(typeof number);
}

bar();
// undefined
```

在函数里没有用 `let` 声明 `number` 的时候，`number` 是 `undefined`，讲道理在 `let` 声明前也应该是 `5`，然而 `foo` 函数却报了错，证明了就算是在未到达 `let` 声明的地方，但是在用 `let` 之前已经起到了作用。这是不是说明其实 `let` 也有提升（这个提升并不是 `var` 的那种提升，只是有影响），只是在 TDZ 使用的时候报错了，而不是 `undefined`。

事实上，当 JavaScript 引擎检视下面的代码块有变量声明时，对于 `var` 声明的变量，会将声明提升到函数或全局作用域的顶部，而对 `let` 或 `const` 的时候会将声明放在暂时性死区内。

任何在暂时性死区内访问变量的企图都会导致 **运行时错误**（Runtime Error）。只有执行到变量的声明语句时，该变量才会从暂时性死区内被移除并可以安全使用。

#### 1.4.5 显式块级作用域

在嵌套的作用域内使用 `let` 声明同一变量是被允许的。这个嵌套的作用域，在 ES6 中又称 **显式块级作用域**。

```js
var foo = 1;

{
  // 不会报错
  let = 2;
  // other code
}
```

同时因为是 `let` 和 `const` 是块级作用域，声明的变量在当前块使用完之后就会被释放，所以就算使用相同的标识符也不会覆盖外部作用域的变量, 而 `var` 是会覆盖外部作用域的变量的。

```js
function foo() {
  var bar = 1;
  {
    let bar = 2;
  }

  console.log(bar);
}

function zoo() {
  var bar = 1;
  {
    var bar = 2;
  }

  console.log(bar);
}

foo(); // 1
zoo(); // 2
```

在 ECMAScript 6 的发展阶段，被广泛认可的变量声明方式是：默认情况下应当使用 `let` 而不是 `var` 。

对于多数 JavaScript 开发者来说， `let` 的行为方式正是 `var` 本应有的方式，因此直接用 `let` 替代 `var` 更符合逻辑。在这种情况下，你应当对 **需要受到保护的变量** 使用 `const`。

在默认情况下使用 `const` ，而只在你知道变量值 **需要被更改** 的情况下才使用 `let` 。这在代码中能确保基本层次的不可变性，有助于防止某些类型的错误。

### 1.5 声明提升

JavaScript 程序的运行阶段分为 **预编译阶段** 和 **执行阶段**。

在预编译阶段，JavaScript 引擎会做一件事情，那就是读取 `变量的定义` 并 `确定其作用域` 即生效范围。

- 变量定义
  - 使用 `var` 或 `let` 关键字定义的变量，在未赋值的情况下，该变量的值是 `undefined`
  - 使用 `const` 关键字定义变量却不赋值，将会抛出错误
- 变量作用域
  - 全局变量的作用域遍布全局
  - 局部变量的作用域仅在于函数内部及其嵌套函数的作用域
  - 函数内部的同名变量或参数优先级高于全局同名变量

在 JavaScript 中，如果变量或函数没有声明就被使用，会引致错误的。

```js
console.log(a);
// Uncaught ReferenceError: a is not defined
```

**声明提升** 包括 **变量声明提升** 和 **函数声明提升**：

- **变量声明提升**：通过 `var`、`let` 和 `const` 声明的变量在代码执行之前被 JavaScript 引擎提升到当前作用域的顶部
- **函数声明提升**：通过函数声明的方式（非函数表达式）声明的函数在代码执行之前被 JavaScript 引擎提升了当前作用域的顶部，而且 **函数声明提升优先于变量声明提升**

JavaScript 的代码在生成前，会先对代码进行编译，编译的一部分工作就是找到所有的声明，然后建立作用域将其关联起来，因此，在 **当前作用域内** 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。

注意这里是 **声明** 会被提前处理，**赋值** 并没有， 定义声明是在编译阶段进行的，而赋值是在执行阶段进行的 。也就是说声明提升了，赋值还留着原地，等待执行。

#### 1.5.1 变量声明提升

```js
console.log(a);
var a = 2;
console.log(a);
```

```js
var a;
// 变量声明 默认赋值 undefined

comsole.log(a);
// 输出变量a undefined

a = 2;
// 给a赋值2

console.log(a);
// 输出变量 a 为 2
```

#### 1.5.2 函数声明提升

函数的两种创建方式：

- 函数声明
- 函数表达式

```js
foo();
// 输出 'bar'

function foo() {
  console.log('bar');
}
```

```js
foo();
// 报错：foo is not a function

var foo = function () {
  console.log('bar');
};
```

解析：同样地先执行函数，后创建函数，结果却是不一样。原因在于，通过函数声明的方式，该 **函数声明**（包括定义）会被提升至作用域的顶部，而表达式的创建方式则只提升了变量 `foo` 至作用域的顶部，此时的 `foo` 其值为`undefined`，调用 `foo` 自然报错：`foo` 不是一个方法。

```js
var foo = function () {
  console.log('1');
};

function foo() {
  console.log('2');
}

foo();
// '1'
```

预编译阶段进行变量声明提升和函数声明提升后，上述代码执行效果等同于：

```js
// 变量声明提升
const foo;

// 函数声明提升
function foo(){
  console.log('2');
}

// 变量赋值保持原位执行，foo 函数被覆盖
foo = function(){
  console.log('1');
};

foo();
// '1'
```

总结：

- 函数声明提升，会将函数的声明和定义全都提升至作用域顶部
- 变量声明提升，只提升声明部分（未赋值状态），赋值部分保持原位置不动

#### 1.5.3 函数覆盖

函数声明和变量声明都会被提升。但是，**函数声明会覆盖变量声明**。

```js
var a;

function a() {}

console.log(a);
// 'function a(){}'
```

但是，如果变量存在赋值操作，则最终的值为变量的值。

```js
var a = 1;
function a() {}
console.log(a);
// 'function a(){}'

var a;
function a() {}
console.log(a);
// 'function a(){}'

a = 1;
console.log(a);
// 1
```

**变量的重复声明是无用的**，但**函数的重复声明会覆盖前面的声明**（无论是变量还是函数声明）。

##### 1.5.3.1 重复声明无效

```js
var a = 1;
var a;
console.log(a);
```

输出结果为 1，以上代码等同于：

```js
// 此时 a 的默认值为 undefined
var a;

a = 1;

console.log(a);
// 1
```

##### 1.5.3.2 函数声明优先

由于函数声明提升优先于变量声明提升，所以变量的声明无效。

```js
var a;

function a() {
  console.log(1);
}

a();
// 1
```

##### 1.5.3.3 函数声明覆盖

后面的函数声明会覆盖前面的函数声明。

```js
a();
// 2

function a() {
  console.log(1);
}

function a() {
  console.log(2);
}
```

### 1.6 闭包

在了解闭包之前，先要熟悉以下几点：

1. 首先要理解执行环境（[执行上下文栈](https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/execution/execution-context-stack)），执行环境定义了变量或函数有权访问的其他数据。
2. 每个执行环境都有一个与之关联的 [变量对象](https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/execution/variable-object)，环境中定义的所有变量和函数都保存在这个对象中。
3. 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入到一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。
4. 当某个函数被调用时，会创建一个执行环境及其相应的 **作用域链**。然后使用 `arguments` 和其他命名参数的值来初始化函数的活动对象。在函数中，活动对象作为变量对象使用（*作用域链是由每层的变量对象使用链结构链接起来的*）。
5. 在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，直到作用域链终点即全局执行环境。
6. **作用域链的本质是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。**

#### 1.6.1 定义

**闭包的定义**：指有权访问另一个函数作用域中的变量的函数，一般情况就是在一个函数中包含另一个函数。

**闭包的作用**：访问函数内部变量、保持函数在环境中一直存在，不会被垃圾回收机制处理

函数内部声明的变量是局部的，只能在函数内部访问到，但是函数外部的变量是对函数内部可见的。

子级可以向父级查找变量，逐级查找，直到找到为止或全局作用域查找完毕。

因此我们可以在函数内部再创建一个函数，这样对内部的函数来说，外层函数的变量都是可见的，然后我们就可以访问到他的变量了。

```js
function foo() {
  let value = 1;

  function bar() {
    console.log(value);
  }

  return bar();
}

const baz = foo();

// 这就是闭包的作用，调用 foo 函数，就会执行里面的 bar 函数，foo 函数这时就会访问函数外层的变量
baz();
```

`bar` 包含 `foo` 内部作用域的闭包，使得该作用域能够一直存活，不会被垃圾回收机制处理掉，这就是闭包的作用，以供 `bar` 在任何时间进行引用。

#### 1.6.2 执行过程分析

我们通过一段代码仔细分析上述代码片段执行过程到底发生了什么：

```js
function foo() {
  var a = 2;

  function bar() {
    console.log(a);
  }

  return bar;
}

var baz = foo();

baz();
```

1. 代码执行流进入全局执行环境，并对全局执行环境中的代码进行声明提升。
2. 执行流执行 `var baz = foo` ，调用 `foo` 函数，此时执行流进入 `foo` 执行环境中，对该执行环境中的代码进行声明提升过程。此时执行环境栈中存在两个执行环境，`foo` 函数为当前执行流所在执行环境。
3. 执行流执行代码 `var a = 2;`，对 `a` 进行 LHS 查询，给 `a` 赋值 2。
4. 执行流执行 `return bar` ，将 `bar` 函数作为返回值返回。按理说，这时 `foo` 函数已经执行完毕，应该销毁其执行环境，等待垃圾回收。但因为其返回值是 `bar` 函数。`bar` 函数中存在自由变量 `a`，需要通过作用域链到 `foo` 函数的执行环境中找到变量 `a` 的值，所以虽然 `foo` 函数的执行环境被销毁，但其变量对象不能被销毁，**只是从活动状态变成非活动状态**；而全局环境的变量对象则变成活动状态；执行流继续执行 `var baz = foo`，把 `foo` 函数的返回值 `bar` 函数赋值给 `baz`。
5. 执行流执行 `baz` ，通过在全局执行环境中查找 `baz` 的值，`baz` 保存着 `foo` 函数的返回值 `bar`。所以这时执行 `baz` ，会调用 `bar` 函数，此时执行流进入 `bar` 函数执行环境中，对该执行环境中的代码进行声明提升过程。此时执行环境栈中存在三个执行环境，`bar` 函数为当前执行流所在的执行环境。
6. 在声明提升的过程中，由于 `a` 是个自由变量，需要通过 `bar` 函数的作用域链 `bar -> foo -> 全局作用域` 进行查找，最终在 `foo` 函数中找到 `var a = 2;` ，然后在 `foo` 函数的执行环境中找到 `a` 的值是 2，所以给 `a` 赋值 2。
7. 执行流执行 `console.log(a)` ，调用内部对象 `console`，并从 `console` 对象中找到 `log` 方法，将 `a` 作为参数传递进去。从 `bar` 函数的执行环境中找到 `a` 的值是 2，所以，最终在控制台显示 2。
8. 执行流执行完 `bar` 函数后，`bar` 的执行环境被弹出执行环境栈，并被销毁，等待垃圾回收，控制权还给全局执行环境。
9. 当页面关闭时，所有执行环境都被销毁。

```js
// 执行上下文栈
ECStack = [
  globalContext
]

// 全局执行上下文
global = {
  VO: [global],
  Scope: [globalContext.VO],
  this: globalContext.VO
}

// 函数foo被创建，保存作用域链到函数内部属性[[Scopes]]
foo.[[Scopes]] = [
  globalContext.VO
]
```

```js
// foo函数执行上下文
fooContext = {
  AO: {
    a: undefined,
    bar: function () {
      console.log(a);
    },
    arguments: [],
  },
  Scope: [AO, globalContext.VO],
  this: undefined,
};
```

```js
// bar 函数执行上下文
barContext = {
  AO: {
    a: undefined,
    arguments: [],
  },
  Scope: [AO, globalContext.VO],
  this: undefined,
};
```

当 `bar` 函数执行的时候，`foo` 函数上下文已经被销毁了（亦即从执行上下文栈中被弹出），怎么还会读取到 `foo` 作用域下的 `a` 值呢？

当我们了解了具体的执行过程后，我们知道 `bar` 函数执行上下文维护了一个作用域链：

```js
barContext = {
  Scope: [AO, fooContext.AO, globalContext.VO],
};
```

对的，就是因为这个作用域链，`bar` 函数依然可以读取到 `fooContext.AO` 的值，说明当 `bar` 函数引用了 `fooContext.AO` 中的值的时候，即使 `fooContext` 被销毁了，但是 JavaScript 依然会让 `fooContext.AO` 活在内存中，`bar` 函数依然可以通过 `bar` 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。

#### 1.6.3 应用场景

闭包的常见应用场景：

- **函数嵌套**：函数里面的函数能够保证外面的函数的作用域不会被销毁，所以无论是在函数里面还是在外面调用函数里面的函数都可以访问到外层函数的作用域，具体做法可以将里面函数当做返回值返回后通过两次的括号调用
- **回调函数**：回调函数会保留当前外层的作用域，然后回调到另一个地方执行，执行的时候就是闭包
- **匿名函数自执行**：严格算也不是闭包，就是 `(function(){})()` 这种格式

```js
function hoc(a, b) {
  return function () {
    console.log(a, b);
  };
}

const fn = hoc(1, 2);

setTimeout(fn, 3000);
```

一般 `setTimeout` 的第一个参数是个函数，但是不能传值。如果想传值进去，可以调用一个函数返回一个内部函数的调用，将内部函数的调用传给 `setTimeout`。内部函数执行所需的参数，外部函数传给他，在 `setTimeout` 函数中也可以访问到外部函数。

#### 1.6.4 优缺点

- 优点：能够让希望一个变量长期驻扎在内存之中成为可能，避免全局变量的污染，以及允许私有成员的存在
- 缺点：就是常驻内存会增大内存使用量，并且使用不当容易造成内存泄漏

如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其他函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。