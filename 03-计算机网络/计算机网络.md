## 第一章、计算机网络体系

### 1.1 计算机网络体系

![](./img/1-1-OSI七层模型.gif)

![](./img/1-1-OSI七层模型对比.jpg)

#### 1.1.1  OSI七层模型

- 应用层：允许访问OSI环境的手段（应用协议数据单元 APDU）
- 表示层：对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）
- 会话层：建立、管理和终止会话（会话协议数据单元 SPDU）
- 传输层：提供端到端的可靠报文传递和错误恢复（段 Segment）
- 网络层：负责数据包从源到宿的传递和网际互连（包 PackeT）
- 数据链路层：将比特组装成帧和点到点的传递（帧 Frame）
- 物理层：通过媒介传输比特,确定机械及电气规范（比特 Bit）

#### 1.1.2 TCP/IP 概念层模型

- **应用层**（Application Layer）的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则**。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等
- **传输层**（Transport Layer）的主要任务就是 **负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。
- **网络层**的任务就是选择合适的网间路由和交换结点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称数据报。
- **数据链路层**（Data Link Layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层接下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。
- 在**物理层**上所传送的数据单位是比特。 物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。 在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。

### 1.2 传输层协议

传输层（Transport Layer）的主要任务就是负责向两台主机进程之间的通信提供通用的 **数据传输服务**。应用进程利用该服务传送应用层报文。

网络协议族中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。

- 传输控制协议 TCP：提供面向连接的，可靠的数据传输服务
- 用户数据协议 UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）

#### 1.2.1 TCP

传输控制协议（Transmission Control Protocol，简称 TCP）是一种 面向连接（连接导向）的、可靠的、 基于 IP 协议的传输层协议。

- 面向连接：每条 TCP 连接只能有两个端点（亦即点对点，不可广播、多播），每一条 TCP 连接只能是一对一
- 可靠的传输服务：通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达，丢包时通过重传机制进而增加时延实现可靠性
- 全双工通信：TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据
- 字节流：面向字节流，TCP 中的 流（Stream）指的是流入进程或从进程流出的字节序列
- 流量缓冲：解决速度不匹配问题

![](./img/1-2-1-TCP.jpeg)

数据包结构：TCP 首部标志比特有 6 个：URG、ACK、PSH、RST、SYN、FIN

| 控制位 | 名称             | 说明                             |
| ------ | ---------------- | -------------------------------- |
| URG    | Urgent Flag      | 紧急指针                         |
| ACK    | Acknowledge Flag | 确认序号有效                     |
| PSH    | Push Flag        | 尽可能快地将数据送往接收进程     |
| RST    | Reset Flag       | 可能需要重现创建建 TCP 连接      |
| SYN    | Synchronize      | 同步序号来发起一个连接           |
| FIN    | Finish           | 发送方完成发送任务，要求释放连接 |
| Seq    | Sequance number  | 序列号                           |

##### 1.2.1.1 三次握手

TCP 提供 **面向连接** 的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作，也就是说无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。

**握手的目标：**

- 同步连接双方的 Sequence 序列号和确认号
  - 初始序列号 ISN
- 交换 TCP 窗口大小信息
  - 如 MSS、窗口比例因子、选择性确认、指定校验和算法

![](./img/1-1-2-1-三次握手.JPG)

1. **第一次握手**：**建立连接**。客户端发送连接请求报文段，将标志比特位 SYN 置为 1，随机产生一个序列号码 Sequence Number 值为 X（由操作系统动态随机选取一个 32 位长的序列号），并将该数据包发送给服务端，客户端进入 `SYN_SENT` 状态，等待服务端确认。
2. **第二次握手**：**服务端收到 SYN 报文段**。服务端收到数据包后需要对标志位 SYN 报文段进行确认，确认后设置确认号码 Acknowledgment Number 为 X+1（Sequence Number+1）；同时，自己还要发送 SYN 请求信息（以建立服务端对客户端的连接），将 SYN 设置为 1，设置 Sequence Number 值为 Y（由操作系统动态随机选取一个 32 位长的序列号），服务端将上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端**以确认建立连接请求**，服务端进入 `SYN_RCVD` 状态。
3. **第三次握手**：**客户端收到服务端的 SYN+ACK 报文段**。确认后，然后将 Acknowledgment Number 设置为 Y+1，向服务端发送 ACK 报文段，这个报文段发送完毕后，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

握手过程中传送的包里不包含数据，只有三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

##### 1.2.1.2 未连接队列

在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的 SYN 包（syn=j）开设一个条目，该条目表明服务器已收到 SYN 包，并向客户端发出确认，正在等待客户端的确认包。这些条目所标识的连接在服务器处于 SYN_RECV 状态，当服务器收到客户端的确认包时，删除该条目，服务器进入 ESTABLISHED 状态。

##### 1.2.1.3 为什么建立 TCP 连接需要三次握手？

主要是为了防止服务端开启无用的连接。

因为我们知道网络传输是有延时的，因为终端间隔了非常远的距离，数据包通过光纤以及各种中间代理服务器进行传输，但是在服务端和客户端的传输过程中，往往由于网络传输的不稳定原因丢失了数据包，客户端一直没有收到服务端返回的数据包，客户端可能设置了超时时间关闭了连接创建，那么就会再发起新的请求。如果没有第三次握手，服务端是不知道客户端到底有没有接收到服务端返回给他的数据的，客户端也没有一个确认说要关闭还是要创建这个请求，服务端的端口就一直开着，等着客户端发送实际的请求数据，那么这个时候开销就浪费了，服务端不知道这个连接已经创建失败了，可能客户端已经创建别的连接去了。

所以我们需要三次握手来确认这个过程，让服务端和客户端能及时察觉到网络原因导致的网络连接的关闭的问题，从而规避网络传输中因为延时导致导致的服务器开销问题。

##### 1.2.1.4 第三次握手可以发送数据吗？为何？

可以。因为能够发出第三次握手报文的主机，肯定接收到第二次（来自服务端）的握手报文。因为伪造 IP 的主机不会收到第二次报文。

##### 1.2.1.5 四次挥手

四次挥手即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送 4 个包以确认连接的断开。在 Socket 编程中，这一过程由客户端或服务端任一方执行 close 来触发。

由于 TCP 连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 FIN 来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到这一方向也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

![](./img/1-2-1-5-四次挥手.jpg)

1. **第一次挥手**：客户端设置 Sequence Number，发送一个 `FIN` 报文段，用于关闭客户端到服务器端的数据传送，客户端进入 `FIN_WAIT_1` 状态。意思是说「我客户端没有数据要发给你了」，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。
2. **第二次挥手**：服务器端收到 `FIN` 报文段，回复 `ACK` 报文段，Acknowledgment Number 为 Sequence Number 加 1，告诉客户端，你的请求我收到了，我同意你的关闭请求。这个时候客户端就进入 `FIN_WAIT_2` 状态。
3. **第三次挥手**：当服务器端确定数据已发送完成，则向客户端发送 `FIN` 报文段，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入 `LAST_ACK` 状态。
4. **第四次挥手**：客户端收到 `FIN` 报文段后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送 `ACK` 报文段回复服务端，然后进入 `TIME_WAIT` 状态，如果服务端端没有收到 `ACK` 则可以重传。服务器端收到 `ACK` 后，就知道可以断开连接了。客户端等待了 2MSL（通常是两分钟）后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

##### 1.2.1.6 为什么断开 TCP 连接需要四次挥手？

由于 TCP 连接采取全双工的通信方式，因此每个方向都必须单独进行关闭，这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

##### 1.2.1.7 为什么基于 TCP 的程序往往都有个应用层的心跳检测机制？

TCP 建立链接后，只是在两端的内核里面维持 TCP 信息，实际上并没有一个物理的连接通路，对端这个时候挂了，谁也不知道。

#### 1.2.2 UDP

用户数据报协议（User Datagram Protocol，UDP），又称使用者资料包协定，是一个简单的面向数据包的传输层协议，正式规范为 RFC 768。

在 TCP/IP 模型中，UDP 为网络层以上和应用层以下提供了一个简单的接口。UDP 只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以 UDP 有时候也被认为是不可靠的数据报协议）。UDP 在 IP 数据报的头部仅仅加入了复用和数据校验（字段）。

- **无需建立连接**（减少延迟）
- 尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态
- UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短
- 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如直播，实时视频会议等）
- 支持一对一、一对多、多对一和多对多的交互通信

##### 1.2.2.1 基于 UDP 协议的有

- 域名系统（DNS）
- 简单网络管理协议（SNMP）
- 动态主机配置协议（DHCP）
- 路由信息协议（RIP）
- 自举协议（BOOTP）
- 简单文件传输协议（TFTP）

#### 1.2.3 数据通信形式

- 单工数据传输只支持数据在一个方向上传输
- 半双工数据传输允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信
- 全双工数据通信允许数据同时在两个方向上传输，因此，**全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力**

#### 1.2.3 TCP 与 UDP对比

|          | TCP                   | UDP                      |
| -------- | --------------------- | ------------------------ |
| 连接性   | 面向连接              | 无连接                   |
| 双工性   | 全双工（1:1）         | `n:m`                    |
| 可靠性   | 可靠（重传机制）      | 不可靠（丢包后数据丢失） |
| 有序性   | 有序（通过 SYN 排序） | 无序                     |
| 有界性   | 无，有沾包情况        | 有消息边界，无沾包       |
| 拥塞控制 | 有                    | 无                       |
| 传输速度 | 慢                    | 快                       |
| 量级     | 低                    | 20-60 字节               |
| 头部大小 | 高                    | 8 字节                   |

### 1.3 网络层与数据链路层协议

网络层用来处理在网络上流动的数据包（数据包：网络上传输的最小数据单位）。网络层规定在众多选项中通过怎样的路径（传输线路）到达对方的计算机，把数据包传输给对方。

该层中最突出的协议是 Internet Protocol（IP），因此该层也称为 IP 层。IP 的核心是两个主要功能：**地址** 和 **路由**。

IP 协议是 TCP / IP 协议的核心，所有的 TCP、UDP、IMCP、IGMP 的数据都以 IP 数据格式传输。要注意的是，IP 不是可靠的协议，这是指 IP 协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP 或 UDP 要做的事情。

网络层功能：

- IP 寻址
- 选路
- 封装打包
- 分片

数据链路层功能：

- 逻辑链路控制
- 媒体访问控制
- 封装链路层帧
- MAC 寻址
- 差错检测与处理
- 定义物理层标准

#### 1.3.1 IPv4 分类地址

在数据链路层中我们一般通过 MAC 地址来识别不同的节点，而在 IP 层我们也要有一个类似的地址标识，这就是 IP 地址。

32 位 IP 地址（IPv4 地址的点分十进制表示）分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。

| IP 地址类别 | 首字节      | 网络号 Bit 数 | 主机号 Bit 数 | 理论地址范围                    | 预期用途                         |
| ----------- | ----------- | ------------- | ------------- | ------------------------------- | -------------------------------- |
| A 类地址    | `0xxx xxxx` | 8             | 24            | `1.0.0.0` ~ `126.255.255.255`   | 特大网络的单播传输               |
| B 类地址    | `10xx xxxx` | 16            | 16            | `128.0.0.0` ~ `191.255.255.255` | 数千台中大型网络的单播传输       |
| C 类地址    | `110x xxxx` | 24            | 8             | `192.0.0.0` ~ `223.255.255.255` | 250 台主机以下小型网络的单播传输 |
| D 类地址    | `1110 xxxx` | n/a           | n/a           | `224.0.0.0` ~ `239.255.255.255` | IP 多播                          |
| E 类地址    | `1111 xxxx` | n/a           | n/a           | `240.0.0.0` ~ `255.255.255.255` | 预留实验用                       |

#### 1.3.2 CIDR 子网掩码

无类别域间路由（Classless Inter-Domain Routing，CIDR）是一个用于给用户分配 IP 地址以及在互联网上有效地路由 IP 数据包的对 IP 地址进行归类的方法。

表示方法：`A.B.C.D/N`（N 的范围 `[0, 32]`）

#### 1.3.3 链路层 MAC 地址

- 链路层地址 MAC（Media Access Control Address）
  - 实现本地网络设备间的直接传输
- 网络层地址 IP（Internet Protocol address）
  - 实现大型网络间的传输

#### 1.3.4 地址解析协议 ARP

动态地址解析协议（Address Resolution Protocol，ARP）是根据 IP 地址获取 MAC 地址的一种协议。

简单的来说 ARP 的作用就是把 IP 地址映射为物理地址，而与之相反的 RARP（逆向 ARP）就是将物理地址映射为 IP 地址。

#### 1.3.5 NAT 地址转换

网络地址转换（Network Address Translation，缩写：NAT；又称网络掩蔽、IP 掩蔽）在计算机网络中是一种在 IP 数据包通过路由器或防火墙时重写来源 IP 地址或目的 IP 地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有 IP 地址访问互联网的私有网络中。它是一个方便且得到了广泛应用的技术。当然，NAT 也让主机之间的通信变得复杂，导致了通信效率的降低。

#### 1.3.6 IPv6

网际协议第 6 版（英语：Internet Protocol version 6，缩写：IPv6）是网际协议的最新版本，用作互联网的协议。用它来取代 IPv4 主要是为了解决 IPv4 地址枯竭问题，同时它也在其他方面对于 IPv4 有许多改进。

IPv6 目的：

- 更大的地址空间：128 位长度
- 更好的地址空间管理
- 消除 NAT 等寻址技术
- 更简易的 IP 配置管理
- 优秀的选路设计
- 更好的多播支持
- 安全性
- 移动性

IPv6 二进位制下为 128 位长度，以 16 位为一组，每组以冒号 `:` 隔开，可以分为 8 组，每组以 4 位十六进制方式表示。

### 1.4 DNS 域名解析系统

**DNS 域名解析系统（Domain Name System）** 是进行域名（domain name）和与之相对应的 IP 地址（IP address）转换的服务器。DNS 中保存了一张域名（domain name）和与之相对应的 IP 地址（IP address）的表，以解析消息的域名。

使用 IP 地址而非使用域名进行通信的原因：

- IP 地址是固定长度，IPv4 是 32 位，IPv6 是 128 位，而域名是变长的，不便于计算机处理
- IP 地址对于用户来说不方便记忆，但域名便于用户使用

简单来说就是 IP 面向主机，域名面向用户。

#### 1.4.1 域名的分层结构

由于因特网的用户数量较多，所以因特网在命名时采用的是层次树状结构的命名方法。任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名（domain name）。这里，**域**（domain）是名字空间中一个可被管理的划分。从语法上讲，每一个域名都是有标号（label）序列组成，而各标号之间用点（`.`）隔开。域名可以划分为各个子域，子域还可以继续划分为子域的子域，这样就形成了顶级域、主域名、子域名等。

**域名系统必须要保持唯一性。**

特点：

1. 每个域名都是一个标号序列，用字母（大小写等价）、数字（0-9）和连接符（-）组成
2. 标号序列总长度不能超过 255 个字符，它由各标点之间用 `.` 分割成一个个的标号
3. 每个标号应该在 63 个字符之内，每个标号都可以堪称一个层次的域名
4. 级别最低的域名写在左边，级别最高的域名写在右边

域名服务是基于 UDP 实现的，服务器的端口号为 `53`。

以 `www.example.google.com` 为例：

- `.com`：是顶级域名
- `google.com`：是主域名（也可称托管一级域名），主要指企业名
- `example.google.com`：是子域名（也可称为托管二级域名）
- `www.example.google.com`：是子域名的子域（也可称为托管三级域名）

域名可以划分为各个子域，子域还可以继续划分为子域的子域，这样就形成了顶级域、二级域、三级域等。

| 顶级域名     | 标识                                                         |
| ------------ | ------------------------------------------------------------ |
| 国家顶级域名 | 中国 `cn`；美国 `us`；英国 `uk`                              |
| 通用顶级域名 | 公司企业 `com`；教育机构 `edu`；政府部门 `gov`；国际组织 `int`；军事部门 `mil`；网络 `net`；非盈利组织 `org` |
| 反向域名     | Arpa 用于 PTR 查询（IP 地址转换为域名）                      |

#### 1.4.2 查询类型

- 递归查询
  - 递归查询（Recursive）是一种 DNS 服务器的查询模式，在该模式下 DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果 DNS 服务器本地没有存储查询 DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。所以，一般情况下服务器跟内网 DNS 或直接 DNS 之间都采用递归查询。
- 迭代查询
  - DNS 服务器另外一种查询方式为迭代查询，DNS 服务器会向客户机提供其他能够解析查询请求的 DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台 DNS 服务器地址，客户机再向这台 DNS 服务器提交请求，依次循环直到返回查询的结果。所以一般内网 DNS 和外网 DNS 之间的都采用迭代查询。

#### 1.4.3 分层结构

域名是分层结构，域名 DNS 服务器也是对应的层级结构。有了域名结构，还需要有域名 DNS 服务器去解析域名，且是需要由遍及全世界的域名 DNS 服务器去解析，域名 DNS 服务器实际上就是装有域名系统的主机。域名解析过程涉及 4 个 DNS 服务器，分别如下：

| 分类           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| 根 DNS 服务器  | Root NameServer，本地域名服务器在本地查询不到解析结果时，则第一步会向它进行查询，并获取顶级域名服务器的 IP 地址。 |
| 顶级域名服务器 | TLD（Top-level） NameServer。负责管理在该顶级域名服务器下注册的二级域名，例如 `www.example.com`、`.com` 则是顶级域名服务器，在向它查询时，可以返回二级域名 `example.com` 所在的权威域名服务器地址 |
| 权威域名服务器 | Authoritative NameServer。在特定区域内具有唯一性，负责维护该区域内的域名与 IP 地址之间的对应关系，例如云解析 DNS。 |
| 本地域名服务器 | DNS Resolver 或 Local DNS。本地域名服务器是响应来自客户端的递归请求，并最终跟踪直到获取到解析结果的 DNS 服务器。例如用户本机自动分配的 DNS、运营商 ISP 分配的 DNS、谷歌/114 公共 DNS 等 |

#### 1.4.3 记录类型

在 DNS 系统中，最常见的资源记录方式是 Internet 类记录，该记录由包含 4 个字段的数据构成：`Name`、`Value`、`Type`、`TTL`。

其中 `Name` 和 `Value` 可以理解为一对键值对，但是其具体含义取决于 `Type` 的类型，`TTL` 记录了该条记录应当从缓存中删除的时间。

在资源记录的类型中中，最为常见且重要的类型 `Type` 主要有：

| 说明     |                                                              |
| -------- | ------------------------------------------------------------ |
| A        | 将域名指向一个 IPv4 地址，`A` 记录用于描述目标域名到 IP 地址的映射关系，将目标域名与 `A` 记录的 `Name` 字段进行匹配，将成功匹配的记录的 Value 字段的内容（IP 地址）输出到 DNS 回应报文中。 |
| CNAME    | 将域名指向另一个域名，`CNAME` 记录用于描述目的域名和别名的对应关系，如果说 `A` 记录可以将目标域名转换为对应主机的 IP 地址，那么 `CNAME` 记录则可以将一个域名（别名）转换为另一个域名，如果多条 `CNAME` 记录指向同一个域名，则可以将多个不同的域名的请求指向同一台服务器主机。并且，`CNAME` 记录通常还对应了一条 `A` 记录，用于提供被转换的域名的 IP 地址 |
| NS       | 将子域名指向另一个 DNS 服务器解析，`NS` 记录用于描述目标域名到负责解析该域名的 DNS 的映射关系，根据目标域名对 `NS` 记录的 `Name` 字段进行匹配，将成功匹配的记录的 `Value` 字段（负责解析目标域名的 DNS 的 IP 地址）输出到 DNS 回应报文中 |
| AAAA     | 将域名指向一个 IPv6 地址                                     |
| MX       | 将域名指向邮件服务器地址                                     |
| SRV      | 记录提供特定的服务的服务器                                   |
| TXT      | 文本长度限制 512，通常做 SDF 记录（反垃圾邮件）              |
| CAA      | CA 证书颁发机构授权校验                                      |
| 显性 URL | 将域名重定向至另一个地址                                     |
| 隐形 URL | 与显性 URL 类似，但是会隐藏真实的目标地址                    |

#### 1.4.4 解析过程

DNS 是一种使用 UDP 协议进行域名查询的协议，其最主要的目标就是将域名转换为 IP 地址。

DNS 查询的结果通常会在本地域名服务器中进行缓存，如果本地域名服务器中有缓存的情况下，则会跳过如下 DNS 查询步骤，很快返回解析结果。下面的示例则概述了本地域名服务器没有缓存的情况下，DNS 查询所需的 8 个步骤：

1. 用户在 Web 浏览器中输入 `www.taobao.com`， 则由本地域名服务器开始进行递归查询。
2. 本地域名服务器采用 **迭代查询** 的方法，向根域名服务器进行查询 。
3. 根域名服务器告诉本地域名服务器，下一步应该查询的顶级域名服务器 `.com` TLD 的 IP 地址
4. 本地域名服务器向顶级域名服务器 `.com` TLD 进行查询
5. `.com` TLD 服务器告诉本地域名服务器，下一步查询 `www.taobao.com` **权威域名服务器**的 IP 地址
6. 本地域名服务器向 `www.taobao.com` 权威域名服务器发送查询
7. `www.taobao.com` 权威域名服务器告诉本地域名服务器所查询的主机 IP 地址
8. 本地域名服务器最后把查询的 IP 地址响应给 Web 浏览器，一旦 DNS 查询的 8 个步骤返回了 `www.taobao.com` 的 IP 地址，浏览器就能够发出对网页的请求：
9. 浏览器向 IP 地址发出 HTTP 请求
10. 该 IP 处的 web 服务器返回要在浏览器中呈现的网页

![](./img/1-4-4-DNS.jpeg)

**详细解析：**

以查询 `www.taobao.com` 对应的 IP 地址为例，操作系统首先会在本地尝试解析，比如使用众所周知的 `hosts` 文件，同时如果有解析缓存的话，操作系统也会去查询。如果是在浏览器中进行查询，浏览器自己有时也会有解析缓存。

- 用户设备
  - 浏览器可能会缓存域名解析
  - 用户系统中可以有自己的域名映射表
- 公共域名服务器
  - 通常由 ISP 提供
  - 缓存上一级域名服务器的结果

在查询没有结果时，设备最终会开始向域名服务器发起查询请求。公共域名服务器一般就是用户的 ISP 提供的。这种公共域名服务器通常会缓存查询结果，因此如果缓存命中，查询就可以到此结束。当然缓存本身是有时效的，这个时效就被称为 TTL。对于超过时效的查询结果，域名服务器有义务重新发起查询请求。但查询本身是非常消耗流量的事情，因此也有一些公共服务器不严格遵守 TTL，超时缓存。

未命名缓存的查询，公共服务器会向顶级域名服务器进行查询。以上述例子来说，因为公共域名服务器不知道 `taobao.com` 的解析权归谁，因此它会向顶级域名服务器 ——`com` 域名服务器发起请求，寻找 `taobao.com` 对应的域名服务器。顶级域名服务器一般是由域名经营机构来维护的，有些甚至归属国家机关管理，例如国别域名。理论上来说，在顶级域名服务器之上还有一个根域名服务器，不过在平时很难意识到它的存在。

- 公共域名服务器
  - DNS 级联的特性决定了中途可以有更多域名服务器
- 顶级域名服务器
  - 由顶级域名经营机构维护
  - 可细分为与国家、通用

在查找到 `taobao.com` 的域名服务器之后，就可以向域名服务器查询 `www.taobao.com` 的 IP 了。这个过程是由上到下指定下来的，所以这种域名服务器可以被称为权威域名服务器。对于开发者来说，我们自己平时在域名服务器那里购买到域名之后，录入自己域名对应的 IP，其实就是在向权威域名服务器录入信息。一些大型企业会自己维护权威域名服务器，这样既可以抵御一些针对性的攻击，同时也可以更好地优化解析的速度。

- 公共域名服务器
- 权威域名服务器
  - 通常由专业的域名服务机构提供
  - 购买域名时一般会提供

#### 1.4.5 排查与优化

#####  1.4.5.1 常见问题

- DNS 服务器本身有问题，响应慢并且不稳定
- 或者是，客户端到 DNS 服务器的网络延迟比较大
- 再或者，DNS 请求或者响应包，在某些情况下被链路中的网络设备弄丢了

##### 1.4.5.2 故障排查顺序

1. 检查本地 `hosts`：`cat /etc/hosts`  windows上在`C:\Windows\System32\drivers\etc\hosts`
2. 检查 `resolv.conf` 文件：`cat /etc/resolv.conf`。在 `Redhat7 / Centos7` 上修改 `resolv.conf` 里的 DNS 地址后，重启启网络服务发现 DNS 地址消失了，那么检查下网卡配置文件。
3. 检查网卡配置文件：`cat /etc/sysconfig/network-scripts/ifcfg-<网卡名称>`，看下里头有没 DNS 配置信息，没有的话补上去。

##### 1.4.5.3 常见优化技术

1. HttpDNS：客户端基于 HTTP 协议，向 CDN 服务商指定的 DNS 服务器发送域名解析请求，从而避免 LocalDNS 造成的域名劫持和跨网访问
2. Http 302 跳转：CDN 厂商维护 CDN 域名 IP 库，根据用户访问终端的 IP 和 CDN 边缘节点的状态，选择最合适的 CDN 节点，发出 HTTP 的 302 返回码，将用户的请求跳转到合适的 CDN 边缘节点。

##### 1.4.5.4 常见优化方法

- 缓存：缓存是最有效的方法，但要注意，一旦缓存过期，还是要去 DNS 服务器重新获取新记录。不过，这对大部分应用程序来说都是可接受的。
- 预解析：这是浏览器等 Web 应用中最常用的方法，也就是说，不等用户点击页面上的超链接，浏览器就会在后台自动解析域名，并把结果缓存起来。
- HTTPDNS：使用 HTTPDNS 取代常规的 DNS 解析。这是很多移动应用会选择的方法，特别是如今域名劫持普遍存在，使用 HTTP 协议绕过链路中的 DNS 服务器，就可以避免域名劫持的问题。
- 全局负载均衡：基于 DNS 的全局负载均衡（GSLB）。这不仅为服务提供了负载均衡和高可用的功能，还可以根据用户的位置，返回距离最近的 IP 地址。
- 对于移动客户端，在 APP 启动时对需要解析的域名做预先解析，然后把解析的结果缓存到本地的一个 LRU 缓存里面。这样当我们要使用这个域名的时候，只需要从缓存中直接拿到所需要的 IP 地址就好了，如果缓存中不存在才会走整个 DNS 查询的过程。同时为了避免 DNS 解析结果的变更造成缓存内数据失效，我们可以启动一个定时器定期地更新缓存中的数据。

##### 1.4.5.5 DNS 污染解决方案

一般是考虑尽可能自主控制 DNS 解析，比如使用专用 DNS 服务器，HTTPDNS，甚至是直接使用 IP 地址跳过解析

#### 1.4.6 常用 DNS

- 114 DNS：`114.114.114.114` 或 `114.114.115.115`
- 阿里 DNS：`223.5.5.5` 或 `223.6.6.6`
- 百度 DNS：`180.76.76.76`
- DNS 派：
  - 电信 `101.226.4.6`
  - 联通 `123.125.81.6`
  - 移动 `101.226.4.6`
  - 铁通 `101.226.4.6`
- OneDNS
  - 南方 `112.124.47.27`
  - 北方 `114.215.126.16`
  - 共用 `42.236.82.22`
- Google DNS：`8.8.8.8` 或 `8.8.4.4`
- OpenDNS：`208.67.222.222` 或 `208.67.220.220`
- 360 DNS：`101.226.4.6` 或 `123.125.81.6`

### 1.5 CDN 内容分发网络

**內容分发网络（Content Delivery Network 或 Content Distribution Network，简称 CDN）** 通过将源站内容分发至 **最接近用户** 的节点，从而 **降低核心系统负载（系统、网络）**，使用户可就近取得所需内容，**提高用户访问的响应速度**。这种技术方案解决了因分布、带宽、服务器性能带来的访问延迟问题，适用于图片小文件、大文件下载、音视频点播、全站加速和安全加速等场景。

#### 1.5.1 工作原理

通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN 系统能够实时地根据 **网络流量** 和 **各节点的连接**、**负载状况** 以及 **到用户的距离** 和 **响应时间** 等综合信息将用户的请求重新导向离用户最近的服务节点上。

CDN = 更智能的镜像 + 缓存 + 流量导流;

CDN 是一个经策略性部署的整体系统，包括**分布式存储**、**负载均衡**、**网络请求的重定向** 和 **内容管理** 4 个要件，而内容管理和全局的网络流量管理（Traffic Management）是 CDN 的核心所在。

#### 1.5.2 工作流程

用户终端访问 CDN 的过程分为两个步骤，一是用户通过 DNS 找到最近的 CDN 边缘节点 IP，二是数据在网络中送达用户终端。

最简单的 CDN 网络由一个 DNS 服务器和几台缓存服务器组成，假设您的加速域名为 `www.taobao.com`，接入 CDN 网络，开始使用加速服务后，当终端用户（广州）发起 HTTP 请求时，处理流程如下：

![](./img/1-5-2-cdn工作流程.jpg)

1. 当终端用户（广州）向 `www.taobao.com` 下的某资源发起请求时，首先向 LDNS（本地 DNS）发起域名解析请求。
2. LDNS 检查缓存中是否有 `www.taobao.com` 的 IP 地址记录。如果有，则直接返回给终端用户；如果没有，则向授权 DNS 查询。
3. 当授权 DNS 解析 `www.taobao.com` 时，返回域名 CNAME `www.taobao.alicdn.com` 对应 IP 地址。
4. 域名解析请求发送至 DNS 调度系统，并为请求分配最佳节点 IP 地址。
5. LDNS 获取 DNS 返回的解析 IP 地址。
6. 用户获取解析 IP 地址。
7. 用户向获取的 IP 地址发起对该资源的访问请求。
   - 如果该 IP 地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤 7 和 8，请求结束。
   - 如果该 IP 地址对应的节点未缓存该资源，则节点向它的上级缓存服务器请求内容，直至追溯到网站的源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，途中的杭州节点，并返回给用户，请求结束。

*Local DNS 通常是你的运营商提供的 DNS，一般域名解析的第一站会到这里 回源 HOST 是指 CDN 节点在回源过程中，在源站访问的站点域名。*

在步骤四中，DNS 调度系统可以实现负载均衡功能，负载均衡分为全局负载均衡和区域负载均衡，其内部逻辑大致如下：

1. CDN 全局负载均衡设备会根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的**区域负载均衡设备**，告诉用户向这台设备发起请求。
2. 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：
   - 根据用户 IP 地址，判断哪一台服务器距用户最近；
   - 用户所处的运营商；
   - 根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；
   - 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。 基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的 IP 地址。
3. 全局负载均衡设备把服务器的 IP 地址返回给用户。

#### 1.5.3 组成部分

典型的 CDN 系统由下面三个部分组成：

- **分发服务系统**：最基本的工作单元就是 Cache 设备，Cache（边缘 Cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时 Cache 还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache 设备的数量、规模、总服务能力是衡量一个 CDN 系统服务能力的最基本的指标。
- **负载均衡系统**：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。GSLB 主要根据用户就近性原则，通过对每个服务节点进行”最优“判断，确定向用户提供服务的 Cache 的物理位置。SLB 主要负责节点内部的设备负载均衡
- **运营管理系统**：分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。

CDN 通常由源站负责内容生产，主干节点负责二级缓存和加速，通常在 BGP 网络。

广义上的内容分发网络可以包含源站一起，甚至多媒体分发（视频）。商业意义上的 CDN 只包含 CDN 提供商的网络，不包含源站。部分 CDN 支持图片及多媒体处理扩展等附加功能：压缩、剪切、水印、鉴黄。

**CDN切面**

![](./img/1-5-3-cnd切面.jpg)

**CDN 数据流向**

![](./img/1-5-3-CDN 数据流向.jpg)

#### 1.5.4 应用场景

##### 1.5.4.1 网站加速

站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器 ECS，静态资源如各类型 HTML、CSS、JS、图片、文件、短视频等，建议结合对象存储 OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。

![](./img/1-5-4-1-网站加速.png)

建议将 CDN 产品与 OSS 产品结合使用，可以加速资源的加载速度，提高网站图片、短视频等分发效率。

**业务价值：**

- 终端用户访问慢：网站小文件内容多打开速度太慢
- 跨区域访问质量差：终端用户分布在不同区域，不同区域的访问速度和质量高低不一
- 高并发压力大：运营推广期间，源站服务器压力大，容易挂掉，造成服务不可用
- 图片格式分辨率处理复杂：无法根据适合的终端情况进行图片压缩和优化

##### 1.5.4.2 超大文件下载

大文件下载优化加速分发：网站或应用 App 的主要业务为大文件下载，例如：安装包文件 `apk`、音频文件 `mp3`、驱动程序 `exe`、应用更新文件 `zip` 等，平均单个文件大小在 20M 以上，如游戏、各类客户端下载和 App 下载商店等。

![](./img/1-5-4-2-超大文件下载.png)

**业务价值：**

- 终端用户无法下载或者下载太慢。
- 网络环境不稳定时，下载容易中断。重新下载会耗费额外的资源。
- 网站内容不安全，容易被劫持。
- 文件存储成本过高，同时对源站性能要求高。

##### 1.5.4.3 音视频点播

音视频点播优化加速服务：网站或应用 App 的主要业务为视频点播或短视频类。支持例如：`mp4`、`flv`、`rmvb`、`wmv`、`HLS` 等主流视频格式。

视音频点播主要适用于各类视音频站点，如影视类视频网站、在线教育类视频网站、新闻类视频站点、短视频社交类网站以及音频类相关站点和应用。

CDN 支持流媒体协议，例如 RTMP 协议。在很多情况下，这相当于一个代理，从上一级缓存读取内容，转发给用户。由于流媒体往往是连续的，因而可以进行预先缓存的策略，也可以预先推送到用户的客户端。

对于静态页面来讲，内容的分发往往采取 **拉取** 的方式，也即当发现未命中的时候，再去上一级进行拉取。但是，流媒体数据量大，如果出现回源，压力会比较大，所以往往采取主动推送的模式，将热点数据主动推送到边缘节点。

对于流媒体来讲，很多 CDN 还提供 **预处理** 服务，也即文件在分发之前，经过一定的处理。例如将视频转换为不同的码流，以适应不同的网络带宽的用户需求；再如对视频进行分片，降低存储压力，也使得客户端可以选择使用不同的码率加载不同的分片。这就是我们常见的，超清、标清、流畅等。

 **业务价值：**

- 终端用户访问视频时打不开视频或容易卡顿，观看不流畅。
- 上传、转码、存储、分发、播放的开发配置流程复杂，点播服务技术门槛高。
- 视频资源容易被劫持或盗用，版权得不到有效保护。
- 终端客户上传的小视频等内容无法被快速审核，导致政策风险。

##### 1.5.4.4 音视频直播

视频流媒体直播服务，支持媒资存储、切片转码、访问鉴权、内容分发加速一体化解决方案。结合弹性伸缩服务，及时调整服务器带宽，应对突发访问流量；结合媒体转码服务，享受高速稳定的并行转码，且任务规模无缝扩展。

##### 1.5.4.5 边缘程序

传统的 CDN 服务是纯粹的缓存和分发服务，缺乏可以直接提供给您的计算能力。访问 CDN 的海量请求中，复杂的计算逻辑必须回服务器源站执行，这增加了您的服务器消耗以及架构的复杂性。ER 可提供直接在 CDN 边缘节点计算处理的能力，将极大提高 CDN 的可定制化，可编程化，从而大量减少需回源的请求，降低用户的请求延时。同时 CDN 边缘节点拥有天然的高可用、高伸缩、全球负载均衡的特性，边缘的计算服务可应用于更多的使用场景。

- Geo：边缘打点服务，可以采集到边缘节点的请求相关信息：如 IP、地理、设备信息等
- Fetch：边缘代理服务，在 JS 代码中调用内置 api fetch 做了 http 自请求，响应给客户端 fetch 的最终内容
- AB test：AB 测试的功能
- Precache/Prefetch：CDN 预热功能，预热任务在响应客户端时将异步完成
- Race：回源同拉功能，将回源速度最快的源站的内容优先返回给客户端
- Log：边缘日志服务，在响应结束后异步地生成日志并回传给您的 Server
- 3xx：回源 302 跟随功能
- Redirect：边缘请求重定向功能
- Deny bot：边缘反爬虫服务
- Waf：边缘 waf 服务，当满足某些条件时，将禁止该请求

通常，使用了 CDN 后，您可以根据延时、下载速度、打开速度、丢包率、回源率和缓存命中率判断加速效果。

#### 1.5.5 动态 CDN

动态加速针对动态资源进行加速分发。

- **边缘计算的模式**：既然数据是动态生成的，所以 **数据的逻辑计算和存储**，也相应的放在边缘的节点。其中定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。就像对生鲜的烹饪是动态的，没办法事先做好缓存，因而将生鲜超市放在你家旁边，既能够送货上门，也能够现场烹饪，也是边缘计算的一种体现。
- **路径优化的模式**：数据不是在边缘计算生成的，而是在源站生成的，但是数据的下发则可以通过 CDN 的网络，对路径进行优化。因为 CDN 节点较多，能够找到离源站很近的边缘节点，也能找到离用户很近的边缘节点。中间的链路完全由 CDN 来规划，选择一个更加可靠的路径，使用类似专线的方式进行访问。

对于常用的 TCP 连接，在公网上传输的时候经常会丢数据，导致 TCP 的窗口始终很小，发送速度上不去。根据前面的 TCP 流量控制和拥塞控制的原理，在 CDN 加速网络中可以调整 TCP 的参数，使得 TCP 可以更加激进地传输数据。可以通过多个请求复用一个连接，保证每次动态请求到达时。连接都已经建立了，不必临时三次握手或者建立过多的连接，增加服务器的压力。另外，可以通过对传输数据进行压缩，增加传输效率。所有这些手段就像冷链运输，整个物流优化了，全程冷冻高速运输。不管生鲜是从你旁边的超市送到你家的，还是从产地送的，保证到你家是新鲜的。

#### 1.5.6 刷新预热

- 刷新功能是指提交 URL 刷新或目录刷新请求后，CDN 节点的缓存内容将会被强制过期，当您向 CDN 节点请求资源时，CDN 会直接回源站获取对应的资源返回给您，并将其缓存。刷新功能会降低缓存命中率。
- 预热功能是指提交 URL 预热请求后，源站将会主动将对应的资源缓存到 CDN 节点，当您首次请求时，就能直接从 CDN 节点缓存中获取到最新的请求资源，无需再回源站获取。预热功能会提高缓存命中率。

## 第二章、HTTP

### 2.1 HTTP 超文本传输协议

HTTP 全称是  HyperText Transfer Protocal ，即超文本传输协议。

- HTTP 是 **应用层协议**，当你上网浏览网页的时候，浏览器和 Web 服务器之间就会通过 HTTP 在 Internet 上进行数据的发送和接收。
- HTTP 是一个基于请求/响应模式的、无状态的协议。

![](./img/2-1-浏览器输入URL完整过程.png)

#### 2.1.1 特点

HTTP 的特点概括如下：

1. **灵活可扩展**：主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。
2. **可靠传输**：HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。
3. **请求-应答**：也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。
4. **无状态**：这里的状态是指 **通信过程的上下文信息**，而每次 HTTP 请求都是独立、无关的，默认不需要保留状态信息。

#### 2.1.2 缺点

1. 无状态：在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 HTTP 的缺点了。
2. 明文传输：WIFI 陷阱 就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。
3. 队头阻塞问题：当 HTTP 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于 阻塞状态，也就是著名的队头阻塞问题。

### 2.2 HTTP 资源标识

#### 2.2.1 统一资源标识符 URI

统一资源标志符（Uniform Resource Identifier，简称 URI）是一个用于标识（区分）互联网资源名称的字符串。该种标识允许用户对网络种的资源通过特定的协议进行交互操作。

URI 可以进一步分为 [URL](https://tsejx.github.io/javascript-guidebook/computer-networks/http/http-resource-and-uris#统一资源定位符-url) 和 [URN](https://tsejx.github.io/javascript-guidebook/computer-networks/http/http-resource-and-uris#永久统一资源定位符-urn)。URI 是以一种抽象的，高层次概念定义统一资源标识，而 URL 和 URN 则是具体的资源标识的方式。

##### 2.2.1.1 编码方式

URI 只能使用 ASCII，ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。

因此，URI 引入了 **编码** 机制，将所有 **非 ASCII 码字符** 和 **界定符** 转为十六进制字节值，然后在前面加个 `%`。

如：空格被转义成了 `%20`，**三元** 被转义成了 `%E4%B8%89%E5%85%83`。

##### 2.2.1.2 方案或协议

`http://` 告诉浏览器使用何种协议。对于大部分 Web 资源，通常使用 HTTP 协议或其安全版本 HTTPS 协议。

另外，浏览器也知道如何处理其他协议。例如，

- `mailto`：协议指示浏览器打开邮件客户端
- `ftp`：协议指示浏览器处理文件传输。

| 方案              | 描述                                   |
| ----------------- | -------------------------------------- |
| `data`            | Data URIs                              |
| `file`            | 指定主机上文件的名称                   |
| `ftp`             | 文件传输协议                           |
| `http` 或 `https` | 超文本传输  协议／安全的超文本传输协议 |
| `mailto`          | 电子邮件地址                           |
| `ssh`             | 安全 shell                             |
| `tel`             | 电话                                   |
| `urn`             | 统一资源名称                           |
| `view-source`     | 资源的源代码                           |
| `ws/wss`          | WebSocket 连接                         |

#### 2.2.2 统一资源定位符 URL

统一资源定位符（Uniform Resource Locator，简称 URL）是 URI 最常见的形式，有时候也被俗称为网页地址（网址），如同是网络上的门牌，是因特网上标准的资源的地址。

```plain
https://developer.mozilla.org
https://developer.mozilla.org/en-US/docs/Learn/
https://developer.mozilla.org/en-US/search?q=URL
```

#### 2.2.3 永久统一资源定位符 URN

永久统一资源定位符（Uniform Resource Name，简称 URN）是另一种形式的 URI，它通过特定命名空间中的唯一名称来标识资源。

```http
urn:isbn:9780141036144
urn:ietf:rfc:7230
```

#### 2.2.4 Data URI Scheme

Data URI Scheme，即前缀为 `data:` 协议的 URI，其允许内容创建者向文档中嵌入小文件。

```
data:[<mediatype>][;charset=][;<encoding>],<encoded-data>
```

Data URI Scheme 由四个部分组成：

- 协议头 `data:`：标识这个内容为 Data URI Scheme 资源
- MIME 类型（可选项）：查看下方详细描述
- 源文本的字符集编码方式 `[;charset=<charset>]`：默认编码是 `charset=US-ASCII`，即数据部分的每个字符都会自动编码为 `%xx`
- 数据编码方式 `[;<encoding>]`：默认 `US-ASCII` 和 `BASE64` 两种
- 编码后的数据 `<encoded data>`

**使用 Data URI Scheme 的优劣势**

- 优势
  - 减少 HTTP 请求
  - 当访问外部资源很麻烦或受限时（例如资源服务器 IP 被禁用）
  - 当图片是在服务端用程序动态生成，每个访问用户显示均不同
  - 当图片的体积比较小，占用 HTTP 会话性价比不高
  - 没有图片更新要重新上传，还要清理缓存的问题
- 劣势
  - Base64 编码的数据体积通常为原数据的 4/3，也就是 Data URI Scheme 形式的图片会比二进制格式的图片体积大 1/3
  - Data URI Scheme 形式的图片不会被浏览器缓存，意味着每次访问页面都需要被重新加载
  - 不适合用于懒加载中
  - 移动端性能优先并不适宜用 Data URI Scheme 技术，解码耗费 CPU

#### 2.2.5 MIME 类型

媒体类型（Multipurpose Internet Mail Extensions，简称 MIME 类型）是一种标准，用于表示文档、文件或字节流的性质和格式。在 HTTP 中，HTTP 会从 MIME 类型中取部分标记报文 Body 部分的数据类型，这些类型体现在 `Content-Type` 这个字段，当然这是针对于发送端而言的，接收端想要收到特定类型的数据，也可以使用 `Accept` 字段。

浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理文档。因此服务器设置正确以将正确的 MIME 类型附加到响应对象的头部是非常重要的。

MIME 类型对大小写不敏感，但是传统写法都是小写。

| 类型        | 描述                                                  | 示例                                                         |
| ----------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| text        | 表明文件是普通文件，理论上是人类可读的                | `text/plain` `text/html` `text/css` `text/javascript`        |
| image       | 表明文件某种是图像文件，GIF 动态图也属于 `image` 属性 | `image/gif` `image/png` `image/jpeg` `image/bmp` `image/webp` `iamge/x-icon` `image/vnd.microsoft.icon` `image/svg+xml` |
| audio       | 表明文件是某种音频文件                                | `audio/midi` `audio/mpeg` `audio/webm` `audio/ogg` `audio/wav` |
| video       | 表明文件是某种视频文件                                | `video/webm` `video/ogg`                                     |
| application | 表明文件是某种二进制数据                              | `application/octet-stream` `application/pkcs12` `application/vnd.mspowerpoint` `application/xhtml+xml` `application/xml` `application/pdf` |

#### 2.2.6 复合类型

```unknown
multipart/form-data
multipart/byteranges
```

Multipart 类型表示细分领域的文件类型的种类，经常对于不同的 MIME 类型。这是复合文件的一种表现方式。

- `multipart/form-data`：用于联系 HTML Forms 和 POST 方法
- `multipart/byteranges`：使用状态码 `206 Partial Content` 来发送整个文件的子集，而 HTTP 对不能处理的复合文件使用特殊的方式，将信息直接传送给浏览器

`multipart/form-data` 可用于 HTML 表单从浏览器发送信息给服务器。作为多部分文档格式，它由边界线（由 `--` 开始的字符串）划分出的不同部分组成。每个部分有自己的实体，以及自己的 HTTP 请求头，`Content-Disposition` 和 `Content-Type` 用于文件上传领域。

#### 2.2.7 MIME 嗅探

在却是 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行 MIME 嗅探。每个浏览器在不同的情况下会执行不同的操作。因为这个操作会有一些安全问题，有的 MIME 类型表示可执行内容而有些是不可执行内容。浏览器可以通过请求头 `Content-Type` 来设置 `X-Content-Type-Options` 以阻止 MIME 嗅探。

### 2.3 HTTP 报文格式

对于 TCP 而言，在传输的时候分为两个部分：TCP 头和数据部分。而 HTTP 报文是面向文本的，报文中的每个字段都是一些 ASCII 码串，各个字段的长度是不确定的。HTTP 有两类报文：**请求报文** 和 **响应报文**。HTTP 请求/响应报文由以下内容组成：

- 请求头
- HTTP 头部字段
- 空行
- 可选的 HTTP 报文主体数据

#### 2.3.1 请求报文

![](./img/2-3-1请求报文.png)

HTTP 的请求报文分为三个部分：

- 请求行
  - 请求方法
  - 请求地址 URL
  - HTTP 协议版本
- 首部行
  - Content-Type
- 空行
- 实体主体

##### 2.3.1.1 请求行

请求行是请求消息的第一行，由三部分组成：

- 请求方法（GET / POST / DELETE / PUT / HEAD）
- 请求资源的 URI 路径
- HTTP 的版本号

```
GET /index.html HTTP/1.1
```

##### 2.3.1.2 请求方法

HTTP/1.1 协议中共定义了八种方法，以不同的方式操作指定的资源。

| 方法名  | 功能                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 向指定的资源发出 **显示** 请求，使用 GET 方法应该只用在 **读取数据** 上，而不应该用于产生 **副作用** 的操作中。 |
| POST    | 指定资源 **提交数据**，请求服务器进行处理（例如提交表单或者上传文件）。**数据被包含在请求文本中**。这个请求可能会创建新的资源或者修改现有资源，或两者皆有。 |
| PUT     | 向指定资源位置上传其 **最新内容**。                          |
| DELETE  | 请求服务器删除 Request-URI 所标识的资源。                    |
| OPTIONS | 使服务器传回该 **资源支持的所有 HTTP 请求方法**。用 `*` 来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。 |
| HEAD    | 与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将 **不传回资源的本文部分**，它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中 `关于该资源的信息`（原信息或称元数据）。 |
| TRACE   | 显示服务器收到的请求，主要用于测试或诊断。                   |
| CONNECT | HTTP/1.1 中预留给能够将连接改为通道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器）。 |

其中，最常见的是 GET 和 POST 方法，如果是 RESful API 接口规范的话一般会用到 POST、DELETE、GET、PUT（分别对应增删查改）。

**GET 与 POST**

HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 GET 请求参数的限制是来源与浏览器或 Web 服务器，浏览器或 Web 服务器限制了 URL 的长度。

为了明确这个概念，我们必须再次强调下面几点：

- HTTP 协议 未规定 GET 和 POST 的长度限制
- GET 的最大长度显示是因为 浏览器和 Web 服务器限制了 URI 的长度
- 不同的浏览器和 Web 服务器，限制的最大长度不一样
- 要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte

**性质**

- GET 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存
- POST 不同，POST 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 GET 请求适合于请求缓存

**两种请求方法的对比**

- 从 **缓存** 的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
- 从 **编码** 的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，中文需要 URL 编码，而 POST 没有限制。
- 从 **参数** 的角度，GET 一般放在 URL 中明文传输，因此不安全，而 POST 放在请求体中密文传输，更适合传输敏感信息。
- 从 **幂等性** 的角度，GET 是幂等的，而 POST 不是。（幂等表示执行相同的操作，结果也是相同的）
- 从 **TCP** 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 `header` 部分，如果服务器响应 100（continue）， 然后发 `body` 部分。（火狐浏览器除外，它的 POST 请求只发一个 TCP 包）

GET 传输数据量限制在 2KB（GET 是通过 URL 提交数据，而 URL 本身对于数据没有限制，但是不同的浏览器对于 URL 是有限制的，比如 IE 浏览器对于 URL 的限制为 2KB，而 Chrome，FireFox 浏览器理论上对于 URL 是没有限制的，它真正的限制取决于操作系统本身），而 POST 对于数据大小是无限制的（真正影响到数据大小的是服务器处理程序的能力）。

##### 2.3.1.3 请求头

请求头中的信息有和缓存相关的头（Cache-Control，If-Modified-Since）、客户端身份信息（User-Agent）等等。

```http
Accept: */*
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Connection: keep-alive
Content-Length: 21429
Content-Type: application/json
Host: api.github.com
Origin: https://github.com
Referer: https://github.com/
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36
```

**常见的请求 Header**

| 请求头            | 说明                                   |
| ----------------- | -------------------------------------- |
| Accept            | 表示浏览器接受的数据类型               |
| Accept-Encoding   | 表示浏览器接受的数据压缩格式           |
| Host              | 表示当前请求访问的目标地址             |
| Authorization     | 表示用户身份认证信息                   |
| User-Agent        | 表示浏览器类型                         |
| If-Modified-Since | 表示当前请求资源最近一次更新时间       |
| If-None-Match     | 表示当前请求资源最近一次标识的 ETag 值 |
| Cookie            | 表示浏览器保存的 Cookie 信息           |
| Referer           | 表示标识请求引用自哪个地址             |

##### 2.3.1.4 请求体

请求体是 POST 请求方式中的请求参数，以 `key = value` 形式进行存储，多个请求参数之间用 `&` 连接，如果请求当中请求体，那么在请求头当中的 Content-Length 属性记录的就是该请求体的长度。

```http
POST hysj.jsp HTTP/1.1
Host: search.cnipr.com
User-Agent: Mozilla/5.0 (Windows;U;Windows NT 6.9;zh-CN;rv:1.9.1.13)Gecko/20100914 Firefox/3.5.13 (.NET CLR 3.5.30729)
Accept: text/html, application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-cn,zh;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charst: GN2312,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://search.cnipr.com/cnipr/zljs/hyjs-biaodan-y.jsp
Content-Length: 405

pageNo=0&pageSize=10&orderNum=306735659327926273&customerMobile=15626000000&startTime=2019-02-01%2000:00:00&endTime=2019-02-25%2014:54:20&status=SUCCESS&source=WECHAT_SHOPPING&canteenId=104&refundStatus=REFUNDED&startPayTime=2019-02-01%2000:00:00&endPayTime=2019-02-25%2014:54:47
```

根据应用场景的不同，HTTP 请求的请求体有三种不同的形式：

1. **任意请求体**：移动开发者常见的，请求体是任意类型的，服务器不会解析请求体，请求体的处理需要自己解析，如 POST、JSON 的时候就是这类
2. **查询字符串**：URL 中 Query String 的格式要求，多个键值对之间用 `&` 连接，键与值之间用 `=` 连接，且只能用 ASCII 字符，非 ASCII 字符需使用 `UrlEncode` 编码
3. **文件上传**：当需要实现 **文件上传** 时，请求体会被分成多个部分，每个字段 / 文件都被首部字段 `Content-Type` 的 **boundary** 指令指定的值分成单独的段，每段以 `--` 加 `boundary` 指令的值开头，然后是该段的描述头，描述头之后空一行接内容，请求结束的标识为 `boundary` 后面加 `--`

![](./img/2-3-1-4-请求体.jpg)

区分是否被当成文件的关键是  `Content-Disposition` 是否包含  `filename`，因为文件有不同的类型，所以还要使用  `Content-Type` 指示文件的类型，如果不知道是什么类型取值可以为 `application/octet-stream` 表示文件是一个二进制的文件，如果不是文件则 `Content-Type` 可以省略。

#### 2.3.2 响应报文

![](./img/2-3-4-响应报文.png)

HTTP 响应的格式上除状态行（第一行）与请求报文的请求行不一样之外，其他的就格式而言是一样的，但排除状态行和请求行的区别，从 Header 上还是可以区分出 HTTP 请求和 HTTP 响应的区别的，怎么区别就要看前面的 Header。

HTTP 的响应报文分为三个部分：

- 状态行
  - HTTP 协议版本
  - 状态码
  - 短语
- 首部行
- 空行
- 实体体

##### 2.3.2.1 状态行

状态码用以表示网页服务器超文本传输协议响应状态的三位数字码。

| 状态码 | 对应信息                                                     |
| ------ | ------------------------------------------------------------ |
| 1XX    | 提示信息，表示请求已接收，继续处理                           |
| 2XX    | 用于表示请求已被成功接收、理解、接收                         |
| 3XX    | 用于表示资源（网页等）被永久转移到其它 URL，也就是所谓的重定向 |
| 4XX    | 客户端错误—请求有语法错误或者请求无法实现                    |
| 5XX    | 服务器端错误—服务器未能实现合法的请求                        |

##### 2.3.2.2 响应头

响应头同样可用于传递一些附加信息。

```http
HTTP/1.0 200 ok
content-type: application/javascript;charset=utf-8
date: Tue, 07 Mar 2017 03:06:14 GMT
sever: Domain Reliability Searver
content-length: 0
x-xss-protection: 1, mode=bloack
x-frame-options: SAMEORIGIN
alt-svc: quic=":443";ma=2592000;v="36,35,34"
```

常见的响应头 Header

| 称                | 作用                                   |
| ----------------- | -------------------------------------- |
| Date              | 表示当前相应资源发送的服务器日期和时间 |
| Last-Modified     | 表示当前响应资源最后被修改的服务器时间 |
| Transfer-Encoding | 表示当前响应资源传输实体的编码格式     |
| Set-Cookie        | 表示设置 Cookie 信息                   |
| Location          | 在重定向中或者创建新资源时使用         |
| Server            | 表示服务器名称                         |

##### 2.3.2.3 响应体

响应体也就是网页的正文内容，一般在响应头中会用 Content-Length 来明确响应体的长度，便于浏览器接收，对于大数据量的正文信息，也会使用 `chunked` 的编码方式。

### 2.4 HTTP 首部字段

HTTP 首部字段用于描述报文。

首部字段的格式特点：

1. 字段名 **不区分大小写**
2. 字段名不允许出现空格，不可以出现下划线 `_`
3. 字段名后必须紧跟着冒号 `:`

#### 2.4.1 报文信息

| 报文形式 | 首部字段名 | 说明                                                   | 示例                                                         |
| -------- | ---------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| 通用     | Date       | 创建报文的日期时间                                     | `Date: Tue, 15 Nov 2010 08:12:31 GMT`                        |
| 请求头   | Origin     | 请求页面的站点地址                                     | `Origin: https://developer.mozilla.org`                      |
|          | Referer    | 请求页面的完整 URL 地址                                | `Referer: https://developer.mozilla.org/en-US/docs/Web/JavaScript` |
|          | Host       | 请求要发送到的资源服务器的主机名和端口号               | `Host: www.taobao.com`                                       |
|          | User-Agent | 用户代理软件的应用类型、操作系统、软件开发商以及版本号 | `User-Agent: Mozilla/5.0 (Linux; X11)`                       |

#### 2.4.2 网络连接

| 报文形式 | 首部字段名 | 说明                                                         | 示例                |
| -------- | ---------- | ------------------------------------------------------------ | ------------------- |
| 通用     | Keep-Alive | 允许消息发送者表示连接的状态，还可以用于设置超时时长和最大请求数 |                     |
|          | Connection | 决定当前事务完成后，是否会关闭网络连接                       | `Connection: close` |

##### 2.4.2.1 Connection

如果取值为 `keep-alive`，网络连接就是持久的，不会关闭，使用对同一服务器的请求可以继续在该连接上完成。

可取值：

- `keep-alive`：表明客户端想要保持该网络连接打开，HTTP/1.1 的请求默认使用一个持久连接。这个请求头列表由头部名组成，这些头将被第一个非透明的代理或者代理间的缓存所移除：这些头定义了发出者和第一个实体之间的连接，而不是和目的地节点间的连接。
- `close`：表明客户端或服务器想要关闭该网络连接，这是 HTTP/1.0 请求的默认值

##### 2.4.2.2 Keep-Alive

`Keep-Alive` 是一个通用消息头，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。

系列用逗号隔开的参数，每一个参数由一个标识符和一个值构成，并使用等号 `=` 隔开。下述标识符是可用的：

- `timeout`：指定空闲连接需要保持打开状态的最小时长（以秒为单位）。需要注意的是，如果没有在传输层设置 `keep-alive` TCP message 的话，大于 TCP 层面的超时设置会被忽略。
- `max`：在连接关闭之前，在此连接可以发送的请求的最大值。在非管道连接中，除了 `0` 以外，这个值是被忽略的，因为需要在紧跟着的响应中发送新一次的请求。HTTP 管道连接则可以用它来限制管道的使用。

```http
HTTP/1.1 200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Thu, 11 Aug 2016 15:23:13 GMT
Keep-Alive: timeout=5, max=1000
Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT
Server: Apache
```

HTTP 请求启动 KeepAlive 需要服务端配合，Nginx 配置：

```nginx
http {
  # 客户端连接在服务器端保持开启的超时值
  keepalive_timeout  120s 120s;
  # 可以服务的请求的最大数量
  keepalive_requests 10000;
}
```

#### 2.4.3 内容协商

| 报文形式 | 首部字段名       | 说明                                          | 示例                                     |
| -------- | ---------------- | --------------------------------------------- | ---------------------------------------- |
| 请求头   | Accept           | 用于告知服务器客户端可处理的 **媒体类型**     | `Accept: text/plain, text/html`          |
|          | Accept-Charset   | 用于告知服务器客户端可处理的 **字符集类型**   | `Accept-Charset: utf-8, iso-8859-5`      |
|          | Accept-Encoding  | 用于告知服务器客户端可处理的 **内容编码方式** | `Accept-Encoding: gzip, deflate, br`     |
|          | Accept-Language  | 用于告知服务器客户端可处理的 **自然语言**     | `Accept-Language: en,zh`                 |
| 响应头   | Content-Type     | 用于指示资源的 **媒体类型**（MIME 类型）      | `Content-Type: text/html; charset=utf-8` |
|          | Content-Encoding | 用于指示资源的 **编码方式**                   | `Content-Encoding: gzip`                 |
|          | Content-Language | 用于指示资源的 **自然语言**                   | `Content-Language: en,zh`                |
|          | Content-Length   | 用于指示资源的 **体积大小**（单位：字节）     | `Content-Length: 348`                    |
|          | Content-Location | 用于指示要访问的资源通过内容协商后的 URL      | `Content-Location: /index.htm`           |
|          | Content-Range    | 表示数据片段在整个文件中的位置                | `Content-Range: bytes 21010-47021/47022` |

##### 2.4.3.1 压缩方式

当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的 Content-Encoding 字段上， 同样的，接收什么样的压缩方式体现在了接受方的 Accept-Encoding 字段上。这个字段的取值有下面几种：

- `gzip`：当今最流行的压缩格式
- `deflate`：另外一种著名的压缩格式
- `br`：一种专门为 HTTP 发明的压缩算法

```http
<!-- 发送端 -->
Content-Encoding: gzip;
<!-- 接收端 -->
Accept-Encoding: gzip
```

##### 2.4.3.2 Content-Type

在响应中，`Content-Type` 用于告知客户端实际返回的内容的内容类型。

指令：

- `media-type`：资源或数据的 MIME 类型
- `charset`：字符编码标准
- `boundary`：用于封装消息的多个部分的边界

#### 2.4.4 同源策略

| 报文形式 | 首部字段名                       | 说明                                                         | 示例                                                         |
| -------- | -------------------------------- | ------------------------------------------------------------ | :----------------------------------------------------------- |
| 请求头   | Access-Control-Request-Headers   | （预检请求）列出正式请求中允许的首部信息                     | `Access-Control-Request-Headers: *`                          |
|          | Access-Control-Request-Method    | （预检请求）列出正式请求中允许的请求方法                     | `Access-Control-Request-Method: *`                           |
| 响应头   | Access-Control-Allow-Credentials | 表示是否可以将对请求的响应暴露给页面                         | `Access-Control-Allow-Credentials: true`                     |
|          | Access-Control-Allow-Headers     | （预检请求）列出正式请求中允许的首部信息                     | `Access-Control-Allow-Headers: *`                            |
|          | Access-Control-Allow-Methods     | （预检请求）列出正式请求中允许的请求方法                     | `Access-Control-Allow-Methods: *`                            |
|          | Access-Control-Allow-Origin      | （预检请求）列出正式请求中允许的域名                         | `Access-Control-Allow-Origin: https://developer.mozilla.org` |
|          | Access-Control-Expose-Headers    | （预检请求）列出正式请求中哪些首部可以暴露                   | `Access-Control-Expose-Headers: Content-Length, X-Kuma-Revision` |
|          | Access-Control-Max-Age           | （预检请求）列出正式请求中 `Access-Control-Allow-Headers` 和 `Access-Control-Allow-Methods` 缓存时间 | `Access-Control-Max-Age: 600`                                |

#### 2.4.5 缓存协商

| 报文形式 | 首部字段名          | 说明                                            | 示例                                                 |
| -------- | ------------------- | ----------------------------------------------- | ---------------------------------------------------- |
| 通用     | Cache-Control       | 表示资源的缓存策略                              | `Cache-Control: no-cache`                            |
| 请求头   | If-Modified-Since   | 比较资源的更新时间                              | `If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT`   |
|          | If-Match            | 比较实体标记（ETag）                            | `If-Match: “737060cd8c284d8af7aD3082f209582d”`       |
|          | If-None-Match       | 比较实体标记（与 If-Match 相反）                | `If-None-Match: “737060cd8c284d8af7ad3082f209582d”`  |
|          | If-Range            | 资源未更新时发送实体 Byte 的范围请求            | `If-Range: “737060cd8c284d8af7ad3082f209582d”`       |
|          | If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） | `If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT` |
| 响应头   | Expires             | 表示资源的过期时间                              | `Expires: Thu, 01 Dec 2010 16:00:00 GMT`             |
|          | Last-Modified       | 表示服务器认定资源最后的修改时间                | `Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT`       |
|          | ETag                | 请求变量的实体标签的当前值                      | `ETag: “737060cd8c284d8af7ad3082f209582d”`           |

#### 2.4.6 权限认证

| 报文形式 | 首部字段名          | 说明                                                   | 示例                                                         |
| -------- | ------------------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| 通用     | Via                 | 代理服务器的相关信息                                   | `Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)`                |
| 请求头   | Authorization       | 用于验证用户代理身份的凭证                             | `Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`          |
|          | Proxy-Authorization | 代理服务器对客户端的认证信息                           | `Proxy-Authenticate: Basic realm="Access to the internal site"` |
| 响应头   | WWW-Authenticate    | 服务器对客户端的认证信息                               | `WWW-Authenticate: Basic`                                    |
|          | Proxy-Authenticate  | 用于指定代理服务器上的资源访问权限而采用的身份验证方式 | `Proxy-Authenticate: Basic realm="Access to the internal site"` |

#### 2.4.7 其他

| 首部字段名        | 说明                                                        | 示例                                           |
| ----------------- | ----------------------------------------------------------- | ---------------------------------------------- |
| Allow             | 资源可支持的 HTTP 方法                                      | `Allow: GET,HEAD`                              |
| Trailer           | 报文末端的首部一览                                          | `Trailer: Max-Forwards`                        |
| Transfer-Encoding | 指定报文主题的传输编码方式                                  | `Transfer-Encoding:chunked`                    |
| Location          | 用来重定向接收方到非请求 URL 的位置来完成请求或标识新的资源 | `Location: http://www.leixuesong.cn/724`       |
| Retry-After       | 如果实体暂时不可取，通知客户端在指定时间之后再次尝试        | `Retry-After: 120`                             |
| Server            | Web 服务器的安装信息                                        | `Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)` |

### 2.5 HTTP 状态码

- **1xx**：表示目前是协议处理的中间状态，还需要后续操作
- **2xx**：表示成功状态
- **3xx**：重定向状态，资源位置发生变动，需要重新请求
- **4xx**：请求报文有误
- **5xx**：服务端发生错误

#### 2.5.1 1xx Informational 信息化

表示临时响应并需要请求者继续执行操作的状态代码。

| 状态码 | 含义                | 说明                                                         |
| ------ | ------------------- | ------------------------------------------------------------ |
| 100    | Continue            | （**继续**）请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 |
| 101    | Switching Protocols | （**交换协议**）请求者已要求服务器切换协议，服务器已确认并准备切换。 |
| 102    | Processing          | （**处理中**）该代码表示服务器已经收到并正在处理请求，但无响应可用。[[6\]](https://zh.wikipedia.org/wiki/HTTP状态码#cite_note-RFC_2518-6)这样可以防止客户端超时，并假设请求丢失。 |

#### 2.5.2 2xx Success 成功

表示成功处理了请求的状态代码。

| 状态码  | 含义                          | 说明                                                         |
| ------- | ----------------------------- | ------------------------------------------------------------ |
| **200** | OK                            | （**成功**）服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 |
| 201     | Created                       | （**已创建**）请求成功并且服务器创建了新的资源。             |
| 202     | Accepted                      | （**已接受**）服务器已接受请求，但尚未处理。                 |
| 203     | Non-Authoritative Information | （**非授权信息**）服务器已成功处理了请求，但返回的信息可能来自另一来源。 |
| 204     | No Content                    | （**无内容**）服务器成功处理了请求，但没有返回任何内容。     |
| 205     | Reset Content                 | （**重置内容**）服务器成功处理了请求，但没有返回任何内容。   |
| 206     | Partial Content               | （**部分内容**）服务器成功处理了部分 GET 请求。使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头 `Content-Range`。 |
| 207     | Multi-Status                  | （**多状态**）代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 |
| 208     | Already Reported              | （**已报告**）DAV 绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。 |
| 226     | IM Used                       | （**使用的**）服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。 |

#### 2.5.3 3xx Redirection 重定向

表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

| 状态码  | 含义               | 说明                                                         |
| ------- | ------------------ | ------------------------------------------------------------ |
| 300     | Multiple Choices   | （**多种选择**）针对请求，服务器可执行多种操作。服务器可根据请求者选择一项操作，或提供操作列表供请求者选择 |
| **301** | Moved Permanently  | （**永久重定向**）请求的网页已永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置（响应头 Location 为新 URL） |
| **302** | Found              | （**临时重定向**）请求的网页已转移到新 URL，Location 首部返回新的 URL，但请求者后续仍然使用原有位置来进行请求 |
| 303     | See Other          | （**查看其他位置**）请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码 |
| **304** | Not Modified       | （**未修改**）自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容 |
| 305     | Use Proxy          | （**使用代理**）请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理 |
| 307     | Temporary Redirect | （**临时重定向**）与 302 类似，唯一区别是不允许将请求方法从 POST 改为 GET |
| 308     | Permanent Redirect | （**永久重定向**） 请求和所有将来的请求应该使用另一个 URI 重复 |

#### 2.5.4 4xx Client Error 客户端错误

这些状态代码表示请求可能出错，妨碍了服务器的处理。

| 状态码  | 含义                            | 说明                                                         |
| ------- | ------------------------------- | ------------------------------------------------------------ |
| **400** | Bad Request                     | （**错误请求**）服务器不理解请求的语法。                     |
| 401     | Unauthorized                    | （**未授权**）请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 |
| 402     | Payment Required                | （**需要付费**）                                             |
| **403** | Forbidden                       | （**禁止**）服务器拒绝请求。比如法律禁止、信息敏感等等。     |
| **404** | Not Found                       | （**未找到**）服务器找不到请求的网页。                       |
| 405     | Method Not Allowed              | （**不允许的方法**）禁用请求中指定的方法。                   |
| 406     | Not Acceptable                  | （**不可接受**）无法使用请求的内容特性响应请求的网页。       |
| 407     | Proxy Authentication Required   | （**需要代理授权**）此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 |
| 408     | Request Timeout                 | （**请求超时**）服务器等候请求时发生超时。                   |
| 409     | Conflict                        | （**冲突**）服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 |
| 410     | Gone                            | （**已删除**）如果请求的资源已永久删除，服务器就会返回此响应。 |
| 411     | Length Required                 | （**需要有效长度**）服务器不接受不含有效内容长度标头字段的请求。 |
| 412     | Precondition Failed             | （**未满足前提条件**）服务器未满足请求者在请求中设置的其中一个前提条件。 |
| 413     | Payload Too Large               | （**请求实体过大**）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 |
| 414     | URI Too Long                    | （**请求的 URI 过长**）请求的 URI（通常为网址）过长，服务器无法处理。 |
| 415     | Unsupported Media Type          | （**不支持的媒体类型**）请求的格式不受请求页面的支持。       |
| 416     | Range Not Satisfiable           | （**请求范围不符合要求**）如果页面无法提供请求的范围，则服务器会返回此状态代码。 |
| 417     | Expectation Failed              | （**未满足期望值**）服务器未满足"期望"请求标头字段的要求。   |
| 422     | Unprocessable Entity            | **（不可处理的实体）**请求格式正确，但是由于含有语义错误，无法响应。 |
| 423     | Locked                          | **（已锁定）**当前资源被锁定。                               |
| 424     | Failed Dependency               | **（失败的依赖）**由于之前的某个请求发生的错误，导致当前请求失败。 |
| 431     | Request Header Fields Too Large | **（请求头过大）**请求头的字段内容太大。                     |

#### 2.5.5 5xx Server Error 服务端错误

这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

| 状态码  | 说明                            |                                                              |
| ------- | ------------------------------- | ------------------------------------------------------------ |
| **500** | Internal Server Error           | （**服务器内部错误）**） 通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。 |
| 501     | Not Implemented                 | （**未执行**）服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 |
| **502** | Bad Gateway                     | （**错误网关**）服务器作为网关或代理，从上游服务器收到无效响应。 |
| 503     | Service Unavailable             | （**服务不可用**）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 |
| 504     | Gateway Timeout                 | （**网关超时**）服务器作为网关或代理，但是没有及时从上游服务器收到请求。 |
| 505     | HTTP Version Not Supported      | （**HTTP 版本不受支持**）服务器不支持请求中所用的 HTTP 协议版本。 |
| 506     | Variant Also Negotiates         | （**变体也进行协商**）                                       |
| 507     | Insufficient Storage            | （**存储空间不足**）服务器无法存储完成请求所必须的内容。     |
| 508     | Loop Detected                   | （**检测到循环**）服务器在处理请求时陷入死循环。             |
| 509     | Bandwidth Limit Exceeded        | （**带宽限制超出**）                                         |
| 510     | Not Extended                    | （**未满足**）获取资源所需要的策略并没有被满足。             |
| 511     | Network Authentication Required | （**网络认证需要**）客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。 |

### 2.6 HTTP 连接

HTTP 连接是 HTTP 报文传输的关键通道。

#### 2.6.1 持久连接

HTTP 协议采用 请求-应答 模式：

- 普通模式：每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接
- Keep-Alive 模式：该功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接

在 HTTP/1.0 版本中，如果客户端浏览器支持 Keep-Alive ，那么就在 HTTP 请求头中添加一个字段 `Connection: Keep-Alive`，当服务器收到附带有 `Connection: Keep-Alive` 的请求时，它也会在响应头中添加一个同样的字段来使用 `Keep-Alive` 。这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（超过 `Keep-Alive` 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。

在 HTTP/1.1 版本中，默认情况下所有连接都被保持，如果加入 `Connection: close` 才关闭。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。

**注意**

- HTTP Keep-Alive 简单来说就是保持当前的 TCP 连接，避免了重新建立连接
- HTTP 长连接不可能一直保持，例如 `Keep-Alive: timeout=5, max=100`，表示这个 TCP 通道可以保持 5 秒，且该长连接最多接收 100 次请求就断开
- HTTP 是无状态协议，意味着每个请求都是独立的，Keep-Alive 没能改变这个结果

**使用长连接后，客户端和服务端如何知道本次传输结束呢？**

1. 判断传输数据是否达到了 `Content-Length` 指示的大小
2. 动态生成的文件采用分块传输的方式传输（`Transfer-Encoding: chunked`），这时候就要根据 `chunked` 编码来判断，`chunked` 编码的数据在最后有一个空 `chunked` 块，表明本次传输数据结束